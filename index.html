<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campe√µes de Nova Insula</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos b√°sicos para centralizar o jogo e definir o fundo */
        body {
            margin: 0;
            overflow: hidden; /* Esconde barras de rolagem */
            background-color: #222; /* Fundo escuro para a p√°gina */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Inter', sans-serif; /* Usando a fonte Inter */
            color: #eee; /* Cor clara para o texto */
        }

        /* Estilos para o canvas da √°rea de jogo */
        canvas {
            background-color: #333; /* Fundo escuro levemente mais claro para a √°rea de jogo */
            border: 5px solid #555; /* Borda ao redor do canvas */
            border-radius: 10px; /* Cantos arredondados */
            display: block; /* Garante que o canvas seja um elemento de bloco */
            touch-action: none; /* Previne a√ß√µes de toque padr√£o como rolagem/zoom */
        }

        /* Exibi√ß√£o de informa√ß√µes do jogo (pontua√ß√£o, n√≠vel, XP) */
        #game-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); /* Fundo semi-transparente */
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2em;
            display: flex;
            gap: 30px; /* Espa√ßamento entre os elementos de informa√ß√£o */
            z-index: 900; /* Garante que esteja acima do canvas, mas abaixo dos modais */
        }

        /* Estilos para todas as caixas de mensagem/modais */
        #message-box, #character-selection, #upgrade-selection, #weapon-selection, #initial-weapon-selection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Centraliza a caixa */
            background-color: rgba(0, 0, 0, 0.9); /* Fundo mais opaco */
            padding: 15px;
            border-radius: 15px; /* Cantos arredondados */
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); /* Sombra para profundidade */
            display: none; /* Escondido por padr√£o */
            z-index: 1000; /* Garante que esteja no topo de tudo */
            max-width: 95%; /* Largura responsiva */
            max-height: 85vh; /* Altura responsiva */
            overflow-y: auto; /* Rolagem para conte√∫do longo */
            box-sizing: border-box; /* Inclui padding no c√°lculo de largura/altura */
        }

        /* T√≠tulos dentro das caixas de sele√ß√£o */
        #character-selection h2, #upgrade-selection h2, #weapon-selection h2, #initial-weapon-selection h2 {
            margin-top: 0;
            color: #fff;
            font-size: 2em;
            margin-bottom: 20px;
        }

        /* Layout de grade para listas de personagens, upgrades e armas */
        #character-list, #upgrade-list, #weapon-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); /* Colunas de grade responsivas */
            gap: 15px;
            justify-content: center;
        }

        /* Grade espec√≠fica para sele√ß√£o de arma inicial */
        #initial-weapon-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            justify-content: center;
        }

        /* Estilos para cart√µes individuais nos menus de sele√ß√£o */
        .character-card, .upgrade-card {
            background-color: #444; /* Fundo mais escuro para cart√µes */
            padding: 8px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Efeitos de hover suaves */
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #555;
        }

        /* Efeitos de hover para cart√µes de personagem */
        .character-card:hover {
            transform: translateY(-5px); /* Efeito de eleva√ß√£o */
            box-shadow: 0 8px 15px rgba(0, 255, 255, 0.3); /* Sombra ciano */
            border-color: deepskyblue; /* Borda ciano */
        }

        /* Efeitos de hover para cart√µes de upgrade/arma */
        .upgrade-card:hover {
            transform: translateY(-5px); /* Efeito de eleva√ß√£o */
            box-shadow: 0 8px 15px rgba(0, 255, 0, 0.3); /* Sombra verde */
            border-color: limegreen; /* Borda verde */
        }

        /* T√≠tulos dentro dos cart√µes */
        .character-card h3, .upgrade-card h3 {
            color: #fff;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 1.2em;
        }

        /* Par√°grafos dentro dos cart√µes */
        .character-card p, .upgrade-card p {
            font-size: 0.8em;
            color: #ccc;
        }

        /* √çcones para personagens e upgrades */
        .char-icon, .upgrade-icon {
            font-size: 2.5em;
            line-height: 1; /* Alinha o √≠cone verticalmente */
        }

        /* Estilo espec√≠fico para t√≠tulo e par√°grafo da caixa de mensagem */
        #message-box h2 {
            margin-top: 0;
            color: #fff;
            font-size: 2em;
        }

        #message-box p {
            font-size: 1.1em;
            color: #ccc;
        }

        /* Estilos para todos os bot√µes */
        #message-box button, #character-selection button, #upgrade-selection button, #weapon-selection button, #initial-weapon-selection button {
            background-color: #4CAF50; /* Fundo verde */
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.1s ease; /* Transi√ß√µes suaves */
            box-shadow: 0 4px #2e7d32; /* Sombra do bot√£o */
        }

        /* Efeito de hover do bot√£o */
        #message-box button:hover, #character-selection button:hover, #upgrade-selection button:hover, #weapon-selection button:hover, #initial-weapon-selection button:hover {
            background-color: #45a049; /* Verde mais escuro no hover */
            transform: translateY(-2px); /* Leve eleva√ß√£o */
        }

        /* Efeito de clique do bot√£o */
        #message-box button:active, #character-selection button:active, #upgrade-selection button:active, #weapon-selection button:active, #initial-weapon-selection button:active {
            transform: translateY(2px); /* Efeito de "pressionar" */
            box-shadow: 0 2px #2e7d32; /* Sombra menor ao pressionar */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="game-info">
        <div id="score-display">Pontua√ß√£o: 0</div>
        <div id="level-display">N√≠vel: 1</div>
        <div id="xp-display">XP: 0/100</div>
    </div>
    <div id="message-box">
        <h2 id="message-title"></h2>
        <p id="message-text"></p>
        <button id="message-button"></button>
    </div>
    <div id="character-selection">
        <h2>Escolha o seu Personagem</h2>
        <div id="character-list"></div>
    </div>
    <div id="upgrade-selection">
        <h2>Selecione um Atributo!</h2>
        <div id="upgrade-list"></div>
    </div>
    <div id="weapon-selection">
        <h2>Escolha uma Nova Arma!</h2>
        <div id="weapon-list"></div>
    </div>
    <div id="initial-weapon-selection">
        <h2>Escolha a Arma Inicial de Teste!</h2>
        <div id="initial-weapon-list"></div>
    </div>

    <script>
        // Obt√©m o elemento canvas e seu contexto de renderiza√ß√£o 2D
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Vari√°veis de estado do jogo
        let gameRunning = false;
        let selectedCharacter = null;
        let isLevelingUp = false;
        let isChoosingWeapon = false;
        let isChoosingInitialWeapon = false;

        // Vari√°veis de dimens√£o do mapa
        let mapWidth = 0;
        let mapHeight = 0;
        let cameraX = 0; // Posi√ß√£o X da c√¢mera (canto superior esquerdo da tela vis√≠vel no mapa)
        let cameraY = 0; // Posi√ß√£o Y da c√¢mera (canto superior esquerdo da tela vis√≠vel no mapa)

        // Objeto do jogador com propriedades iniciais
        let player = {
            x: 0, // Posi√ß√£o X do jogador no mapa (ser√° centralizado no in√≠cio)
            y: 0, // Posi√ß√£o Y do jogador no mapa (ser√° centralizado no in√≠cio)
            radius: 20, // Raio de colis√£o do jogador (AUMENTADO para melhor visibilidade da aura)
            speed: 5, // Velocidade de movimento do jogador
            color: 'deepskyblue', // Cor padr√£o do jogador
            health: 100, // Vida atual
            maxHealth: 100, // Vida m√°xima
            damageMultiplier: 1.0, // Multiplicador de dano do jogador
            collectionRadiusMultiplier: 1.0, // Multiplicador do raio de coleta de orbes de experi√™ncia
            baseProjectileDamage: 5, // Dano base do proj√©til prim√°rio do personagem
            projectileCountMultiplier: 1, // Multiplicador para o n√∫mero de proj√©teis disparados (para armas secund√°rias)
            basicAttackLevel: 0, // N√≠vel do ataque b√°sico (inicializado em 0, definido para 1 em selectCharacter)
            activeWeapons: [], // Array para armazenar armas ativas (escolhidas no level up)
            hasShield: false, // Flag para o status do escudo (da arma Escudo do C√£o)
            lastShieldUsedTime: 0, // Timestamp do √∫ltimo uso do escudo
            isInvulnerable: false, // Flag para invulnerabilidade
            invulnerabilityStartTime: 0, // Timestamp de in√≠cio da invulnerabilidade
            invulnerabilityDuration: 1000, // Dura√ß√£o da invulnerabilidade em ms (1 segundo)
            spriteSheet: null, // Refer√™ncia √† imagem da sprite sheet carregada
            spriteWidth: 0, // Largura de um √∫nico quadro na sprite sheet
            spriteHeight: 0, // Altura de um √∫nico quadro na sprite sheet
            useSprite: false, // Flag para indicar se a sprite deve ser usada
            isMoving: false, // Flag para indicar se o jogador est√° se movendo atualmente
            direction: 'down', // Dire√ß√£o atual para anima√ß√£o da sprite (cardeal)
            movementAngle: Math.PI / 2, // √Çngulo de movimento (em radianos, 0 = direita, PI/2 = baixo)

            // Propriedades da Habilidade Heroica
            heroicCharge: 0,
            maxHeroicCharge: 100, // Exemplo: 100 pontos para carga total
            lastHeroicChargeTime: 0,
            heroicChargeInterval: 1000, // Ganha carga a cada 1 segundo
            heroicChargePerKill: 3, // GANHA 3 DE CARGA POR INIMIGO ABATIDO
            isHeroicAbilityActive: false,
            heroicAbilityEndTime: 0,
            originalBasicAttackInterval: 0, // Para Raim√© e Ito
            originalProjectileCountMultiplier: 0, // Para Kazu
            originalProjectileSpeed: 0, // Para Thorne
            originalProjectileLifespan: 0, // Para Thorne
            originalProjectileRadius: 0, // Para General
            originalEnemySpeed: 0, // Para Gaeru
            originalBasicProjectileDamage: 0, // Para General
        };

        // Arrays de entidades do jogo
        let projectiles = []; // Array de proj√©teis ativos
        let enemies = []; // Array de inimigos ativos
        let experienceOrbs = []; // Array de orbes de experi√™ncia no campo
        let activeAuras = []; // Array de efeitos de aura ativos (ex: Fogo F√°tuo)
        let explosions = []; // Array de efeitos visuais de explos√£o
        let score = 0; // Pontua√ß√£o do jogador
        let currentExperience = 0; // Pontos de experi√™ncia atuais
        let currentLevel = 1; // N√≠vel atual do jogador
        let experienceToNextLevel = 100; // XP necess√°rio para o pr√≥ximo n√≠vel
        let lastBasicAttackTime = 0; // Cooldown para o ataque b√°sico
        let lastEnemySpawnTime = 0; // Timestamp do √∫ltimo spawn de inimigo
        let enemySpawnInterval = 800; // Tempo (ms) entre os spawns de inimigos
        let enemySpeed = 1; // Velocidade base dos inimigos

        // Vari√°veis para aumento de velocidade dos inimigos baseado no tempo
        let gameStartTime = 0; // Timestamp quando o jogo come√ßa oficialmente
        let lastTimeBasedSpeedIncrease = 0; // Timestamp do √∫ltimo aumento de velocidade (a cada 10 minutos)
        const TIME_INTERVAL_FOR_SPEED_INCREASE = 10 * 60 * 1000; // 10 minutos em milissegundos
        const SPEED_INCREASE_PERCENTAGE = 0.005; // Aumento de 0.5%

        const enemyDamageToPlayer = 5; // Dano causado pelos inimigos em colis√£o
        let projectilesToRemove = new Set(); // Conjunto para rastrear proj√©teis a serem removidos
        let enemiesToRemove = new Set(); // Conjunto para rastrear inimigos a serem removidos
        let orbsToSpawn = []; // Array tempor√°rio para orbes gerados a partir da morte de inimigos

        // Utilit√°rio Asset Loader para imagens
        const assetLoader = {
            images: {}, // Armazena objetos de imagem carregados
            imageUrls: {}, // Armazena URLs a serem carregadas
            loadCount: 0, // Contador para imagens carregadas
            totalCount: 0, // Total de imagens a carregar
            // Adiciona uma URL de imagem √† fila do carregador
            addImage(id, url) {
                this.imageUrls[id] = url;
                this.totalCount++;
            },
            // Carrega todas as imagens adicionadas e chama um callback quando conclu√≠do
            loadAll(callback) {
                if (this.totalCount === 0) {
                    callback(); // Se n√£o houver imagens, chama o callback imediatamente
                    return;
                }
                for (const id in this.imageUrls) {
                    const url = this.imageUrls[id];
                    const img = new Image();
                    img.crossOrigin = "Anonymous"; // Necess√°rio para carregar imagens de outras origens
                    img.src = url;
                    img.onload = () => {
                        this.images[id] = img;
                        this.loadCount++;
                        if (this.loadCount === this.totalCount) {
                            callback(); // Todas as imagens carregadas, chama o callback
                        }
                    };
                    img.onerror = () => {
                        console.error(`Falha ao carregar a imagem: ${url}`); // Tratamento de erro para o carregamento da imagem
                        this.loadCount++;
                        if (this.loadCount === this.totalCount) {
                            callback();
                        }
                    };
                }
            },
            // Recupera uma imagem carregada pelo seu ID
            getImage(id) {
                return this.images[id] || null;
            }
        };

        // Propriedades do inimigo atirador
        const shooterEnemyProps = {
            radius: 18, // Um pouco maior que os inimigos normais para distinguir
            color: 'blue', // Cor azul para diferenciar
            health: 40,
            maxHealth: 40,
            attackInterval: 900, // Atira a cada 0.9 segundos (ATUALIZADO)
            projectileDamage: 10, // Dano base do proj√©til do atirador (ATUALIZADO PARA 10)
            projectileRadius: 5,
            projectileSpeed: 3, // Velocidade do proj√©til do atirador (ATUALIZADO)
            projectileLifespan: 65, // 0.8 segundos de dura√ß√£o (48 frames) (ATUALIZADO)
            lastAttackTime: 0, // Adicionado para controlar o cooldown de ataque individual
            type: 'shooter' // Novo tipo para identificar o atirador
        };

        // Defini√ß√µes de Personagens
        const characters = {
            andywn: {
                id: 'andywn', name: 'Andywn', icon: '‚ú®', description: 'Magias fortes, lentas e teleguiadas.',
                playerSpeed: 4.5 * 0.5, // Reduzido pela metade
                playerColor: '#8A2BE2',
                baseProjectileDamage: 20,
                baseProjectileRadius: 10,
                projectileSpeed: 4 * 0.6, // Reduzido em 40% (x 0.6)
                projectileColor: 'purple',
                baseAttackInterval: 800 * 1.4, // Aumentado em 40% (x 1.4)
                projectileLifespan: 120, // 1 segundo (60 frames)
                spriteSheetUrl: 'https://raw.githubusercontent.com/Gawlock/champions-of-nova-insula/refs/heads/main/assets/playersprite/andsheetfinal.png',
                spriteWidth: 40,
                spriteHeight: 40,
                spriteFrames: {
                    up: { sx: 133, sy: 0, sWidth: 133, sHeight: 127 },
                    down: { sx: 0, sy: 0, sWidth: 133, sHeight: 127 },
                    left: { sx: 266, sy: 0, sWidth: 133, sHeight: 127 },
                    right: { sx: 399, sy: 0, sWidth: 133, sHeight: 127 }
                },
                projectileSpriteUrl: 'https://raw.githubusercontent.com/Gawlock/champions-of-nova-insula/refs/heads/main/assets/playersprite/projectileAndy.png',
                projectileSpriteWidth: 30,
                projectileSpriteHeight: 30,
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Destr√≥i instantaneamente todos os inimigos na parte vis√≠vel da tela
                    enemiesRef.forEach(enemy => {
                        // Verifica se o inimigo est√° dentro da tela vis√≠vel (considerando a c√¢mera)
                        const enemyDrawX = enemy.x - cameraX;
                        const enemyDrawY = enemy.y - cameraY;
                        if (enemyDrawX > -enemy.radius && enemyDrawX < canvas.width + enemy.radius &&
                            enemyDrawY > -enemy.radius && enemyDrawY < canvas.height + enemy.radius) {
                            enemiesToRemove.add(enemy);
                            score += Math.round(10 * playerRef.damageMultiplier);
                            orbsToSpawn.push({ x: enemy.x, y: enemy.y, radius: 8, color: 'lightgreen', value: 10 });
                            explosions.push({ x: enemy.x, y: enemy.y, radius: enemy.radius * 2, color: 'magenta', duration: 10, type: 'flash' });
                            // Adiciona carga heroica ao matar
                            if (playerRef.heroicCharge < playerRef.maxHeroicCharge) {
                                playerRef.heroicCharge += playerRef.heroicChargePerKill;
                                playerRef.heroicCharge = Math.min(playerRef.heroicCharge, playerRef.maxHeroicCharge);
                            }
                        }
                    });
                }
            },
            kazu: {
                id: 'kazu', name: 'Kazu', icon: '‚öîÔ∏è', description: 'Espadas m√©dias, r√°pido e teleguiadas.',
                playerSpeed: 5.5 * 0.5, // Reduzido pela metade
                baseProjectileRadius: 7,
                projectileSpeed: 6 * 0.6, // Reduzido em 40%
                projectileColor: 'silver',
                baseAttackInterval: 500 * 1.4, // Aumentado em 40%
                baseProjectileDamage: 5, // Kazu: Proj√©til m√°s forte (2x dano base de 5)
                spriteSheetUrl: 'https://raw.githubusercontent.com/Gawlock/champions-of-nova-insula/refs/heads/main/assets/playersprite/kazusheetfinal2.png',
                spriteWidth: 40,
                spriteHeight: 40,
                spriteFrames: {
                    up: { sx: 133, sy: 0, sWidth: 133, sHeight: 127 },
                    down: { sx: 0, sy: 0, sWidth: 133, sHeight: 127 },
                    left: { sx: 266, sy: 0, sWidth: 133, sHeight: 127 },
                    right: { sx: 399, sy: 0, sWidth: 133, sHeight: 127 }
                },
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Guarda o intervalo de ataque b√°sico original de Kazu
                    playerRef.originalBasicAttackInterval = characters.kazu.baseAttackInterval;
                    // Zera o intervalo de ataque b√°sico para permitir ataques cont√≠nuos
                    characters.kazu.baseAttackInterval = 0; // Definido para 0 para ataques instant√¢neos
                    playerRef.isHeroicAbilityActive = true;
                    playerRef.heroicAbilityEndTime = performance.now() + 30000; // Habilidade dura 30 segundos
                },
                onHeroicAbilityEnd: (playerRef) => {
                    characters.kazu.baseAttackInterval = playerRef.originalBasicAttackInterval; // Restaura
                    console.log("Habilidade Heroica de Kazu terminou. Intervalo de ataque b√°sico restaurado.");
                }
            },
            raime: {
                id: 'raime', name: 'Raim√©', icon: 'üëä', description: 'Socos fortes em arco de 180¬∫, curto alcance.',
                playerSpeed: 5 * 0.5, // Reduzido pela metade
                playerColor: '#CD853F',
                baseProjectileRadius: 12,
                projectileSpeed: 10 * 0.6, // Reduzido em 40%
                projectileColor: 'orange',
                baseAttackInterval: 400 * 1.4, // Aumentado em 40%
                baseProjectileDamage: 12, // Dano base 5 para Raim√© (REVERTIDO PARA 5)
                projectileMaxTravelDistance: 120,
                spriteSheetUrl: 'https://raw.githubusercontent.com/Gawlock/champions-of-nova-insula/refs/heads/main/assets/playersprite/raimesheetfinal.png',
                spriteWidth: 40,
                spriteHeight: 40,
                spriteFrames: {
                    up: { sx: 133, sy: 0, sWidth: 133, sHeight: 127 },
                    down: { sx: 0, sy: 0, sWidth: 133, sHeight: 127 },
                    left: { sx: 266, sy: 0, sWidth: 133, sHeight: 127 },
                    right: { sx: 399, sy: 0, sWidth: 133, sHeight: 127 }
                },
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Reduz o intervalo entre ataques b√°sicos para 0,1 segundos por 30 segundos
                    playerRef.originalBasicAttackInterval = characters.raime.baseAttackInterval; // Guarda o original
                    characters.raime.baseAttackInterval = 100; // 0.1 segundos
                    playerRef.isHeroicAbilityActive = true;
                    playerRef.heroicAbilityEndTime = performance.now() + 30000; // 30 segundos
                },
                onHeroicAbilityEnd: (playerRef) => {
                    characters.raime.baseAttackInterval = playerRef.originalBasicAttackInterval; // Restaura
                }
            },
            thorne: {
                id: 'thorne', name: 'Thorne', icon: 'üéØ', description: 'Tiros r√°pidos de baixo dano nas 4 diagonais.',
                playerSpeed: 5.2 * 0.5, // Reduzido pela metade
                baseProjectileRadius: 4,
                baseProjectileDamage: 20,
                projectileSpeed: 9 * 0.6, // Reduzido em 40%
                projectileColor: 'lightblue',
                baseAttackInterval: 600 * 1.4, // Aumentado em 40%
                spriteSheetUrl: 'https://raw.githubusercontent.com/Gawlock/champions-of-nova-insula/refs/heads/main/assets/playersprite/thornesheetfinal.png',
                spriteWidth: 40,
                spriteHeight: 40,
                spriteFrames: {
                    up: { sx: 133, sy: 0, sWidth: 133, sHeight: 127 },
                    down: { sx: 0, sy: 0, sWidth: 133, sHeight: 127 },
                    left: { sx: 266, sy: 0, sWidth: 133, sHeight: 127 },
                    right: { sx: 399, sy: 0, sWidth: 133, sHeight: 127 }
                },
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Atira em todas as dire√ß√µes e em alta velocidades por 30 segundos, proj√©teis atravessam inimigos
                    playerRef.originalProjectileSpeed = characters.thorne.projectileSpeed;
                    playerRef.originalProjectileRadius = characters.thorne.baseProjectileRadius; // Pode ser √∫til para visual

                    // Ajusta o ataque b√°sico para atirar em 8 dire√ß√µes (4 diagonais + 4 cardinais)
                    // Esta √© uma modifica√ß√£o no comportamento do *spawnProjectile* para Thorne durante a habilidade heroica
                    // Para simplificar, vou adicionar um efeito que modifica temporariamente as propriedades
                    // de como os proj√©teis s√£o criados para Thorne
                    playerRef.isHeroicAbilityActive = true;
                    playerRef.heroicAbilityEndTime = performance.now() + 30000; // 30 segundos
                },
                onHeroicAbilityEnd: (playerRef) => {
                    characters.thorne.projectileSpeed = playerRef.originalProjectileSpeed; // Restaura
                }
            },
            gaeru: {
                id: 'gaeru', name: 'Gaeru', icon: '‚ö°', description: 'Especialista em alvo √∫nico, tiro mais r√°pido, dano muito baixo. M√°s r√°pido na movimenta√ß√£o.',
                playerSpeed: 6.5 * 0.5, // Reduzido pela metade
                playerColor: '#3CB371',
                baseProjectileRadius: 3,
                baseProjectileDamage: 20,
                projectileSpeed: 12 * 0.6, // Reduzido em 40%
                projectileColor: 'lime',
                baseAttackInterval: 300 * 1.4, // Aumentado em 40%
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Paralisa todos inimigos por 40 segundos e duplica a velocidade de ataque do seu ataque b√°sico
                    enemySpeed = 0; // Paralisa inimigos
                    playerRef.originalBasicAttackInterval = characters.gaeru.baseAttackInterval;
                    characters.gaeru.baseAttackInterval /= 2; // Duplica velocidade de ataque
                    playerRef.isHeroicAbilityActive = true;
                    playerRef.heroicAbilityEndTime = performance.now() + 40000; // 40 segundos
                },
                onHeroicAbilityEnd: (playerRef) => {
                    enemySpeed = playerRef.originalEnemySpeed; // Restaura velocidade dos inimigos
                    characters.gaeru.baseAttackInterval = playerRef.originalBasicAttackInterval; // Restaura velocidade de ataque
                }
            },
            general: {
                id: 'general', name: 'General', icon: 'üî´', description: 'Atira tr√™s tiros em leque na dire√ß√£o do inimigo. Dano m√©dio.',
                playerSpeed: 4.8 * 0.5, // Reduzido pela metade
                playerColor: '#696969',
                baseProjectileRadius: 6,
                baseProjectileDamage: 20,
                projectileSpeed: 7 * 0.6, // Reduzido em 40%
                baseAttackInterval: 700 * 1.4, // Aumentado em 40%
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Aumenta o tamanho dos proj√©teis pra 3x, faz eles atravessarem inimigos e reduz o intervalo dos ataques para metade
                    playerRef.originalBasicProjectileDamage = playerRef.baseProjectileDamage; // Guardar original para proj√©teis
                    playerRef.originalBasicAttackInterval = characters.general.baseAttackInterval;
                    playerRef.originalProjectileRadius = characters.general.baseProjectileRadius;

                    characters.general.baseProjectileRadius *= 3;
                    playerRef.baseProjectileDamage *= 1.5; // Aumentar um pouco o dano, j√° que o raio √© maior
                    playerRef.isHeroicAbilityActive = true;
                    playerRef.heroicAbilityEndTime = performance.now() + 30000; // 30 segundos
                },
                onHeroicAbilityEnd: (playerRef) => {
                    characters.general.baseProjectileRadius = playerRef.originalProjectileRadius;
                    playerRef.baseProjectileDamage = player.originalBasicProjectileDamage;
                    characters.general.baseAttackInterval = playerRef.originalBasicAttackInterval;
                }
            },
            ito: {
                id: 'ito', name: 'Ito', icon: 'üç≥', description: 'Proj√©teis de tamanhos aleat√≥rios, curto alcance.',
                playerSpeed: 5.3 * 0.5, // Reduzido pela metade
                playerColor: '#FFD700',
                projectileMinRadius: 5,
                projectileMaxRadius: 15,
                baseProjectileDamage: 20,
                projectileSpeed: 8 * 0.6, // Reduzido em 40%
                baseAttackInterval: 450 * 1.4, // Aumentado em 40%
                projectileLifespan: 30,
                heroicAbility: (playerRef, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, mapWidth, mapHeight) => {
                    // Cura toda a vida instantaneamente e reduz o cooldown do ataque b√°sico para zero por 30 segundos
                    playerRef.health = playerRef.maxHealth;
                    playerRef.originalBasicAttackInterval = characters.ito.baseAttackInterval;
                    characters.ito.baseAttackInterval = 0; // Cooldown zero
                    playerRef.isHeroicAbilityActive = true;
                    playerRef.heroicAbilityEndTime = performance.now() + 30000; // 30 segundos
                },
                onHeroicAbilityEnd: (playerRef) => {
                    characters.ito.baseAttackInterval = playerRef.originalBasicAttackInterval; // Restaura
                }
            },
            teste: {
                id: 'teste', name: 'Teste', icon: 'üß™', description: 'Personagem de teste. Escolha a sua arma inicial!',
                playerSpeed: 5.0 * 0.5, // Reduzido pela metade
                playerColor: '#808000',
                // Personagem Teste n√£o possui habilidade heroica
            }
        };

        // Defini√ß√µes de Upgrades
        const upgrades = {
            might: { name: 'For√ßa', icon: 'üí™', description: 'Aumenta o dano dos seus ataques em 1%.', apply: () => { player.damageMultiplier *= 1.01; } },
            dexterity: {
                name: 'Destreza',
                icon: 'üèÉ‚Äç‚ôÇÔ∏è',
                description: 'Aumenta a velocidade dos seus proj√©teis em 1%.', // Descri√ß√£o ATUALIZADA
                apply: () => {
                    // Aumenta a velocidade de proj√©til do personagem em 1% (multiplica por 1.01)
                    selectedCharacter.projectileSpeed *= 1.01;
                    console.log(`Destreza aplicada! Velocidade de Proj√©til do ${selectedCharacter.name}: ${selectedCharacter.projectileSpeed.toFixed(2)}`); // Log para depura√ß√£o
                }
            },
            willpower: { name: 'Vigor', icon: '‚ù§Ô∏è', description: 'Aumenta a vida m√°xima em 1% e recupera vida proporcionalmente.', apply: () => { const healthIncrease = player.maxHealth * 0.01; player.maxHealth = Math.floor(player.maxHealth + healthIncrease); player.health = Math.min(Math.floor(player.health + healthIncrease), player.maxHealth); } },
            insight: { name: 'Percep√ß√£o', icon: 'üëÅÔ∏è', description: 'Aumenta o raio de coleta de orbes e itens em 20%.', apply: () => { player.collectionRadiusMultiplier *= 1.20; } }
        };

        // Defini√ß√µes de Armas
        const weapons = {
            // Upgrade de Ataque B√°sico - N√≠vel 2
            basic_attack_level_2: {
                id: 'basic_attack_level_2', name: 'Ataque B√°sico Nv. 2', icon: '‚¨ÜÔ∏è', description: 'Aumenta o ataque b√°sico para N√≠vel 2. Proj√©teis +5% e um proj√©til extra com atraso.',
                type: 'basic_attack_level_up', nextLevel: 2,
                trigger: (playerRef) => { playerRef.basicAttackLevel = 2; }
            },
            // Upgrade de Ataque B√°sico - N√≠vel 3
            basic_attack_level_3: {
                id: 'basic_attack_level_3', name: 'Ataque B√°sico Nv. 3', icon: '‚¨ÜÔ∏è‚¨ÜÔ∏è', description: 'Aumenta o ataque b√°sico para N√≠vel 3. Proj√©teis +10% e dois proj√©teis extras com atraso.',
                type: 'basic_attack_level_up', nextLevel: 3,
                trigger: (playerRef) => { playerRef.basicAttackLevel = 3; }
            },
            // Upgrade de Ataque B√°sico - N√≠vel 4
            basic_attack_level_4: {
                id: 'basic_attack_level_4', name: 'Ataque B√°sico Nv. 4', icon: '‚¨ÜÔ∏è‚¨ÜÔ∏è‚¨ÜÔ∏è', description: 'Aumenta o ataque b√°sico para N√≠vel 4. Proj√©teis +15% e tr√™s proj√©teis extras com atraso.',
                type: 'basic_attack_level_up', nextLevel: 4,
                trigger: (playerRef) => { playerRef.basicAttackLevel = 4; }
            },
            // Upgrade de Ataque B√°sico - N√≠vel 5
            basic_attack_level_5: {
                id: 'basic_attack_level_5', name: 'Ataque B√°sico Nv. 5 (M√°x)', icon: '‚ú®‚¨ÜÔ∏è', description: 'Aumenta o ataque b√°sico para N√≠vel 5 (M√°x). Proj√©teis +20% e quatro proj√©teis extras com atraso.',
                type: 'basic_attack_level_up', nextLevel: 5,
                trigger: (playerRef) => { playerRef.basicAttackLevel = 5; }
            },
            rotating_chakram: {
                id: 'rotating_chakram', name: 'Chakram Rotat√≥rio', icon: 'ü•è', description: 'Um proj√©til lento que orbita o personagem e some ap√≥s 3 segundos. Ativa-se a cada 5 segundos.',
                cooldown: 5000, type: 'projectile',
                projectileProps: { radius: 10, speed: 0, color: 'gold', baseDamage: 50, lifespan: 180, type: 'orbiting', orbitRadius: 60, orbitSpeed: 0.1, },
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    const initialOrbitAngle = Math.random() * Math.PI * 2;
                    projectilesRef.push({
                        x: playerRef.x, y: playerRef.y,
                        radius: this.projectileProps.radius,
                        speed: this.projectileProps.speed,
                        color: this.projectileProps.color,
                        damage: this.projectileProps.baseDamage * playerRef.damageMultiplier,
                        lifespan: this.projectileProps.lifespan,
                        type: this.projectileProps.type,
                        orbitRadius: this.projectileProps.orbitRadius,
                        orbitSpeed: this.projectileProps.orbitSpeed,
                        currentOrbitAngle: initialOrbitAngle,
                        creationTime: currentTime
                    });
                }
            },
            dragon_god_sword: {
                id: 'dragon_god_sword', name: 'Espada do Deus Drag√£o', icon: 'üêâ', description: 'Um raio atinge um inimigo aleat√≥rio. Ativa-se a cada 3 segundos, causando dano massivo.',
                cooldown: 3000, type: 'instant_effect',
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    if (enemiesRef.length > 0) {
                        const targetEnemyIndex = Math.floor(Math.random() * enemiesRef.length);
                        const targetEnemy = enemiesRef[targetEnemyIndex];
                        targetEnemy.health -= (50 * playerRef.damageMultiplier);
                        if (targetEnemy.health <= 0) {
                            enemiesToRemove.add(targetEnemy);
                            score += Math.round(10 * playerRef.damageMultiplier);
                            orbsToSpawn.push({ x: targetEnemy.x, y: targetEnemy.y, radius: 8, color: 'lightgreen', value: 10 });
                            // Adiciona carga heroica ao matar
                            if (playerRef.heroicCharge < playerRef.maxHeroicCharge) {
                                playerRef.heroicCharge += playerRef.heroicChargePerKill;
                                playerRef.heroicCharge = Math.min(playerRef.heroicCharge, playerRef.maxHeroicCharge);
                            }
                        }
                        explosions.push({ x: targetEnemy.x, y: targetEnemy.y, radius: 50, color: 'yellow', duration: 15, type: 'flash' });
                    }
                }
            },
            crazy_boomerang: {
                id: 'crazy_boomerang', name: 'Bumerangue Doido', icon: 'ü™É', description: 'Dispara um proj√©til que faz um movimento de "oito" quadruplicado e some ao completar. Dano base: 20. Ativa-se a cada 5 segundos. Atravessa inimigos.', // Descri√ß√£o atualizada
                cooldown: 5000, // Cooldown de 5 segundos
                type: 'projectile',
                projectileProps: {
                    radius: 10,
                    color: 'brown',
                    baseDamage: 20, // Dano base 20
                    type: 'figure_eight',
                    loopDuration: 4000,
                    loopSizeX: 400, // Quadruplicado
                    loopSizeY: 200, // Quadruplicado
                },
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    projectilesRef.push({
                        initialX: playerRef.x, initialY: playerRef.y,
                        x: playerRef.x, y: playerRef.y,
                        radius: this.projectileProps.radius,
                        color: this.projectileProps.color,
                        damage: this.projectileProps.baseDamage * playerRef.damageMultiplier,
                        type: this.projectileProps.type,
                        loopStartTime: currentTime,
                        loopDuration: this.projectileProps.loopDuration,
                        loopSizeX: this.projectileProps.loopSizeX,
                        loopSizeY: this.projectileProps.loopSizeY,
                        creationTime: currentTime
                    });
                }
            },
            fogo_fatuo: {
                id: 'fogo_fatuo', name: 'Fogo F√°tuo', icon: 'üîµ', description: 'Cria um c√≠rculo semitransparente de 10x o raio do personagem. Inimigos dentro levam 50 de dano por segundo. Recarrega a cada 1s e dura 4s.',
                cooldown: 1000, duration: 4000, type: 'timed_effect',
                auraProps: { radiusMultiplier: 10, damage: 50, color: 'darkblue', tickInterval: 1000 },
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    const existingEffect = activeAurasRef.find(eff => eff.id === this.id && eff.type === 'timed_aura_damage');
                    if (!existingEffect) {
                        activeAurasRef.push({
                            id: this.id, type: 'timed_aura_damage',
                            radius: playerRef.radius * this.auraProps.radiusMultiplier,
                            visualRadius: playerRef.radius * this.auraProps.radiusMultiplier, // Corrigido: aura.visualRadius
                            damage: this.auraProps.damage,
                            color: this.auraProps.color,
                            startTime: currentTime,
                            endTime: currentTime + this.duration,
                            nextDamageTime: currentTime,
                            tickInterval: this.auraProps.tickInterval
                        });
                    }
                }
            },
            dog_shield: {
                id: 'dog_shield', name: 'Escudo do C√£o', icon: 'üõ°Ô∏è', description: 'Cria um escudo que protege do pr√≥ximo dano. Recarrega a cada 5 segundos.',
                cooldown: 5000, type: 'passive_effect',
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {}
            },
            strong_bomb: {
                id: 'strong_bomb', name: 'Bomba Forte', icon: 'üí£', description: 'Dispara um proj√©til na sua dire√ß√£o. Ao colidir ou ap√≥s 1s, ele para e explode (3x o tamanho) causando dano em √°rea.',
                cooldown: 2000, type: 'projectile',
                projectileProps: {
                    radius: 12, // Tamanho m√©dio da bomba
                    speed: 5, // Velocidade para andar por 1 segundo
                    color: 'black',
                    baseDamage: 0, // Dano de colis√£o direto da bomba √© zero
                    fuseTime: 60, // 1 segundo de dura√ß√£o (60 frames)
                    type: 'bomb',
                    explosionRadiusMultiplier: 3, // Multiplicador para o raio da explos√£o
                    explosionDamage: 50 // Dano da explos√£o em √°rea
                },
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    const baseAngle = playerRef.movementAngle; // Usa a dire√ß√£o do jogador
                    const dx = Math.cos(baseAngle);
                    const dy = Math.sin(baseAngle);
                    projectilesRef.push({
                        x: playerRef.x, y: playerRef.y,
                        radius: this.projectileProps.radius,
                        speed: this.projectileProps.speed,
                        color: this.projectileProps.color,
                        damage: this.projectileProps.baseDamage * playerRef.damageMultiplier, // Ser√° 0
                        dx: dx, dy: dy,
                        type: this.projectileProps.type, // 'bomb'
                        fuseTime: this.projectileProps.fuseTime,
                        explosionRadius: this.projectileProps.radius * this.projectileProps.explosionRadiusMultiplier,
                        explosionDamage: this.projectileProps.explosionDamage * playerRef.damageMultiplier,
                        spawnTime: currentTime, // Tempo de cria√ß√£o para a fus√£o
                        creationTime: currentTime, // Adicionado para consist√™ncia com outros proj√©teis
                        isCollided: false, // Nova flag para controlar se colidiu
                        isParentBomb: false // N√£o spawna mais filhos
                    });
                }
            },
            holy_heal: {
                id: 'holy_heal', name: 'Cura Sagrada', icon: 'üíö', description: 'Cura 20 de vida. Ativa-se a cada 5 segundos.',
                cooldown: 5000, type: 'instant_effect',
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    playerRef.health = Math.min(playerRef.health + 20, playerRef.maxHealth);
                }
            },
            // Multiplier arma removida
            laser: {
                id: 'laser', name: 'Laser', icon: 'üí•', description: 'Dispara uma linha cont√≠nua que sai da frente do jogador e atravessa o mapa, causando dano a tudo em seu caminho. Ativa-se a cada 4 segundos.',
                cooldown: 4000, type: 'projectile',
                projectileProps: {
                    width: 20, // Aumentado para melhor visibilidade
                    color: 'lime',
                    baseDamage: 40,
                    type: 'laser',
                    speed: 20, // Velocidade aumentada para atravessar rapidamente
                    lifespan: 30, // Dura√ß√£o curta em frames (aprox. 0.5 segundos)
                },
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    const spawnOffset = playerRef.radius + 10; // Inicia 10 pixels √† frente do raio do jogador
                    const angle = playerRef.movementAngle; // Usa a dire√ß√£o atual do jogador

                    const startX = playerRef.x + Math.cos(angle) * spawnOffset;
                    const startY = playerRef.y + Math.sin(angle) * spawnOffset;

                    // O comprimento visual do laser precisa ser grande o suficiente para atravessar o mapa vis√≠vel
                    const dynamicLaserLength = Math.max(mapWidth, mapHeight) * 2; // Garante que cubra a √°rea vis√≠vel e um pouco m√°s

                    projectilesRef.push({
                        x: startX,
                        y: startY,
                        width: this.projectileProps.width,
                        color: this.projectileProps.color,
                        damage: this.projectileProps.baseDamage * playerRef.damageMultiplier,
                        dx: Math.cos(angle),
                        dy: Math.sin(angle),
                        speed: this.projectileProps.speed,
                        angle: angle, // Necess√°rio para a rota√ß√£o do desenho
                        lifespan: this.projectileProps.lifespan, // Agora usa o lifespan curto e finito
                        type: this.projectileProps.type,
                        creationTime: currentTime,
                        visualLength: dynamicLaserLength // Passa o comprimento calculado para o desenho
                    });
                }
            },
            experienced_orb: {
                id: 'experienced_orb', name: 'Experiente', icon: 'üåü', description: 'Faz com que 5 orbes de experi√™ncia extras apare√ßam. Ativa-se a cada 10 segundos.',
                cooldown: 10000, type: 'instant_effect',
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    for (let i = 0; i < 5; i++) {
                        experienceOrbsRef.push({ x: Math.random() * mapWidth, y: Math.random() * mapHeight, radius: 8, color: 'deepskyblue', value: 20 });
                    }
                }
            },
            leech: {
                id: 'leech', name: 'Sanguessuga', icon: 'ü©∏', description: 'Proj√©til super lento de dano alto que cura pela quantidade de dano causado ao matar. Ativa-se a cada 5 segundos.',
                cooldown: 5000, type: 'projectile',
                projectileProps: { radius: 8, speed: 1, color: 'darkred', baseDamage: 100, lifespan: 300, type: 'leech' },
                trigger: function(playerRef, currentTime, enemiesRef, projectilesRef, activeAurasRef, explosionsRef, experienceOrbsRef) {
                    const nearestEnemy = getNearestEnemy(playerRef.x, playerRef.y);
                    const baseAngle = nearestEnemy ? Math.atan2(nearestEnemy.y - playerRef.y, nearestEnemy.x - playerRef.x) : Math.random() * Math.PI * 2;
                    const dx = Math.cos(baseAngle);
                    const dy = Math.sin(baseAngle);
                    projectilesRef.push({
                        x: playerRef.x, y: player.y,
                        radius: this.projectileProps.radius,
                        speed: this.projectileProps.speed,
                        color: this.projectileProps.color,
                        damage: this.projectileProps.baseDamage * playerRef.damageMultiplier,
                        dx: dx, dy: dy,
                        lifespan: this.projectileProps.lifespan,
                        type: this.projectileProps.type,
                        creationTime: currentTime
                    });
                }
            },
            // OP√á√ïES DE LEVEL-UP FIXAS
            heal_hp_levelup: {
                id: 'heal_hp_levelup', name: 'Regenera√ß√£o Instant√¢nea', icon: '‚ù§Ô∏è', description: 'Cura 50 pontos de vida imediatamente.',
                type: 'level_up_bonus', // Novo tipo para identificar op√ß√µes de b√¥nus fixas
                trigger: (playerRef) => { playerRef.health = Math.min(playerRef.health + 50, playerRef.maxHealth); }
            },
            fill_heroic_charge_levelup: {
                id: 'fill_heroic_charge_levelup', name: 'Surto Heroico', icon: '‚ö°', description: 'Adiciona 50 pontos √† sua barra de habilidade heroica.',
                type: 'level_up_bonus', // Novo tipo para identificar op√ß√µes de b√¥nus fixas
                trigger: (playerRef) => { playerRef.heroicCharge = Math.min(playerRef.heroicCharge + 50, playerRef.maxHeroicCharge); }
            }
        };

        // Fun√ß√£o para redimensionar o canvas dinamicamente com base no tamanho da janela
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.9;
            // Limita o tamanho do canvas para telas maiores
            canvas.width = Math.min(canvas.width, 1200);
            canvas.height = Math.min(canvas.height, 800);

            // Atualiza as dimens√µes do mapa quando o canvas √© redimensionado
            mapWidth = canvas.width * 2;
            mapHeight = canvas.height * 2;

            // Se o jogo estiver rodando e nenhum menu estiver aberto, redesenha
            if (gameRunning && !isLevelingUp && !isChoosingWeapon && !isChoosingInitialWeapon) {
                draw();
            }
            // Centraliza o jogador no mapa se o jogo estiver rodando
            if (gameRunning && player) {
                player.x = mapWidth / 2; // Centraliza o jogador no mapa
                player.y = mapHeight / 2; // Centraliza o jogador no mapa
            }
        }

        // Listener de evento para redimensionamento da janela
        window.addEventListener('resize', resizeCanvas);
        // Chamada inicial de redimensionamento do canvas
        resizeCanvas();

        // Objeto para rastrear teclas pressionadas para movimento do jogador
        let keys = { w: false, a: false, s: false, d: false, x: false }; // Adiciona 'x' para a habilidade heroica

        // Listener de evento para pressionar teclas
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = true;
                e.preventDefault(); // Previne o comportamento padr√£o do navegador (ex: rolagem)
            }
            // Ativa a habilidade heroica com 'X'
            if (e.key.toLowerCase() === 'x' && !isLevelingUp && !isChoosingWeapon && !isChoosingInitialWeapon && gameRunning) {
                if (player.heroicCharge >= player.maxHeroicCharge && selectedCharacter.heroicAbility) {
                    player.heroicCharge = 0; // Zera a barra
                    selectedCharacter.heroicAbility(player, enemies, projectiles, activeAuras, explosions, mapWidth, mapHeight);
                }
            }
        });

        // Listener de evento para soltar teclas
        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key.toLowerCase())) {
                keys[e.key.toLowerCase()] = false;
            }
        });

        // Fun√ß√£o para exibir uma caixa de mensagem personalizada
        function showMessageBox(title, text, buttonText, buttonAction) {
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-title').innerHTML = title;
            document.getElementById('message-text').innerHTML = text;
            const msgButton = document.getElementById('message-button');
            msgButton.innerText = buttonText;
            msgButton.onclick = () => {
                msgBox.style.display = 'none'; // Esconde a caixa de mensagem ao clicar no bot√£o
                buttonAction(); // Executa a a√ß√£o fornecida
            };
            msgBox.style.display = 'block'; // Exibe a caixa de mensagem
        }

        // Fun√ß√£o para esconder a caixa de mensagem
        function hideMessageBox() {
            document.getElementById('message-box').style.display = 'none';
        }

        // Fun√ß√£o para encontrar o inimigo mais pr√≥ximo de uma dada coordenada (x, y)
        function getNearestEnemy(x, y) {
            let nearestEnemy = null;
            let minDistance = Infinity;
            if (enemies.length === 0) return null; // Se n√£o houver inimigos, retorna nulo
            enemies.forEach(enemy => {
                const distance = Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestEnemy = enemy;
                }
            });
            return nearestEnemy;
        }

        // Fun√ß√£o para atualizar a UI de informa√ß√µes do jogo (pontua√ß√£o, n√≠vel, XP)
        function updateGameInfoUI() {
            document.getElementById('score-display').innerText = `Pontua√ß√£o: ${score}`;
            document.getElementById('level-display').innerText = `N√≠vel: ${currentLevel}`;
            document.getElementById('xp-display').innerText = `XP: ${currentExperience}/${experienceToNextLevel}`;
        }

        // Fun√ß√£o para exibir o menu de sele√ß√£o de upgrades
        function showUpgradeSelection() {
            hideMessageBox(); // Esconde qualquer caixa de mensagem ativa
            const upgradeSelectionDiv = document.getElementById('upgrade-selection');
            const upgradeListDiv = document.getElementById('upgrade-list');
            upgradeListDiv.innerHTML = ''; // Limpa upgrades anteriores
            for (const upgradeId in upgrades) {
                const upgrade = upgrades[upgradeId];
                const upgradeCard = document.createElement('div');
                upgradeCard.className = 'upgrade-card';
                upgradeCard.onclick = () => applyUpgrade(upgrade); // Atribui o manipulador de clique
                upgradeCard.innerHTML = `<span class="upgrade-icon">${upgrade.icon}</span><h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
                upgradeListDiv.appendChild(upgradeCard);
            }
            upgradeSelectionDiv.style.display = 'block'; // Exibe a sele√ß√£o de upgrades
        }

        // Fun√ß√£o para aplicar um upgrade escolhido
        function applyUpgrade(upgrade) {
            upgrade.apply(); // Executa a fun√ß√£o de aplica√ß√£o do upgrade
            document.getElementById('upgrade-selection').style.display = 'none'; // Esconde a sele√ß√£o de upgrades

            const potentialWeaponChoices = [];

            // 1. Adiciona a pr√≥xima op√ß√£o de upgrade de ataque b√°sico se n√£o estiver no n√≠vel m√°ximo e o personagem n√£o for 'teste'
            if (selectedCharacter.id !== 'teste' && player.basicAttackLevel < 5) {
                const nextBasicAttackLevelId = `basic_attack_level_${player.basicAttackLevel + 1}`;
                if (weapons[nextBasicAttackLevelId]) {
                    potentialWeaponChoices.push(nextBasicAttackLevelId);
                }
            }

            // 2. Adiciona outras armas regulares n√£o ativas e que n√£o sejam as novas op√ß√µes fixas
            for (const weaponId in weapons) {
                const weapon = weapons[weaponId];
                // Exclui a arma 'multiplier' da pool de sele√ß√£o
                if (weapon.id !== 'multiplier' && !weaponId.startsWith('basic_attack_level_') &&
                    !player.activeWeapons.some(w => w.id === weaponId) &&
                    weapon.type !== 'level_up_bonus'
                ) {
                    potentialWeaponChoices.push(weaponId);
                }
            }

            // 3. SOMENTE se n√£o houver outras armas para escolher, adiciona as op√ß√µes fixas de cura e carga heroica
            if (potentialWeaponChoices.length === 0 ||
                (potentialWeaponChoices.length < 3 && (potentialWeaponChoices.includes('heal_hp_levelup') || potentialWeaponChoices.includes('fill_heroic_charge_levelup')))
            ) {
                const fixedOptions = ['heal_hp_levelup', 'fill_heroic_charge_levelup'];
                for (const fixedOptId of fixedOptions) {
                    // Adiciona apenas se j√° n√£o estiver na lista (para evitar duplicatas caso a arma seja um "level_up_bonus" e tamb√©m seja uma das 3 randomizadas)
                    if (!potentialWeaponChoices.includes(fixedOptId)) {
                        potentialWeaponChoices.push(fixedOptId);
                    }
                }
            }

            // Embaralha todas as escolhas potenciais para randomizar a ordem
            const shuffledChoices = potentialWeaponChoices.sort(() => 0.5 - Math.random());

            // Seleciona at√© 3 op√ß√µes *√∫nicas* para exibir
            const choicesToDisplay = [];
            const addedChoices = new Set(); // Usa um Set para garantir a unicidade

            for (const choiceId of shuffledChoices) {
                if (choicesToDisplay.length < 3 && !addedChoices.has(choiceId)) {
                    choicesToDisplay.push(choiceId);
                    addedChoices.add(choiceId);
                }
                if (choicesToDisplay.length === 3) {
                    break; // J√° temos 3 escolhas, podemos parar
                }
            }

            // Se ainda n√£o tiver 3 escolhas ap√≥s adicionar as fixas, pode haver um problema de l√≥gica
            // ou realmente n√£o h√° 3 op√ß√µes distintas. Neste cen√°rio, apenas exibe o que tem.
            // Para garantir 3, mesmo que se repitam as fixas se n√£o houver mais nada:
            while (choicesToDisplay.length < 3) {
                const fixedOptions = ['heal_hp_levelup', 'fill_heroic_charge_levelup'];
                let addedOneThisLoop = false;
                for (const fixedOptId of fixedOptions) {
                    if (!addedChoices.has(fixedOptId)) {
                        choicesToDisplay.push(fixedOptId);
                        addedChoices.add(fixedOptId);
                        addedOneThisLoop = true;
                        break;
                    }
                }
                if (!addedOneThisLoop && choicesToDisplay.length < 3) {
                    const availableAgain = shuffledChoices.filter(id => !addedChoices.has(id));
                    if (availableAgain.length > 0) {
                        choicesToDisplay.push(availableAgain[0]);
                        addedChoices.add(availableAgain[0]);
                    } else if (choicesToDisplay.length < 3) {
                        break;
                    }
                }
            }


            // Exibe o menu de sele√ß√£o de armas com as escolhas selecionadas
            showWeaponSelectionScreen(choicesToDisplay);
        }

        // Renomeada para melhor clareza, pois √© a fun√ß√£o que exibe a tela de sele√ß√£o
        function showWeaponSelectionScreen(weaponIdsToDisplay) {
            isChoosingWeapon = true;
            const weaponSelectionDiv = document.getElementById('weapon-selection');
            const weaponListDiv = document.getElementById('weapon-list');
            weaponListDiv.innerHTML = ''; // Limpa as op√ß√µes anteriores

            weaponIdsToDisplay.forEach(weaponId => {
                const weapon = weapons[weaponId]; // Obt√©m o objeto da arma completo
                const weaponCard = document.createElement('div');
                weaponCard.className = 'upgrade-card';
                weaponCard.onclick = () => selectWeapon(weapon); // Atribui o manipulador de clique
                weaponCard.innerHTML = `<span class="upgrade-icon">${weapon.icon}</span><h3>${weapon.name}</h3><p>${weapon.description}</p>`;
                weaponListDiv.appendChild(weaponCard);
            });
            weaponSelectionDiv.style.display = 'block'; // Exibe a sele√ß√£o de armas
        }

        // Fun√ß√£o para selecionar uma arma durante o level up
        function selectWeapon(weapon) {
            // Lida com upgrades de ataque b√°sico e os novos b√¥nus de level-up
            if (weapon.type === 'basic_attack_level_up' || weapon.type === 'level_up_bonus') {
                weapon.trigger(player); // Ativa a l√≥gica do b√¥nus
            } else {
                // L√≥gica existente para adicionar armas normais √†s armas ativas
                let existingWeapon = player.activeWeapons.find(w => w.id === weapon.id);
                if (!existingWeapon) {
                    const newActiveWeapon = {
                        id: weapon.id,
                        name: weapon.name,
                        cooldown: weapon.cooldown,
                        lastActivatedTime: 0,
                        duration: weapon.duration || 0,
                        isActive: false, // Para efeitos temporizados, indica se est√° atualmente ativo
                        type: weapon.type,
                        trigger: weapon.trigger.bind(weapon),
                        projectileProps: weapon.projectileProps ? { ...weapon.projectileProps } : null,
                        onEnd: weapon.onEnd ? weapon.onEnd.bind(weapon) : null
                    };
                    player.activeWeapons.push(newActiveWeapon);
                    if (newActiveWeapon.type === 'permanent_effect') {
                        newActiveWeapon.trigger(player, performance.now(), enemies, projectiles, activeAuras, explosions, experienceOrbs);
                    }
                }
            }
            document.getElementById('weapon-selection').style.display = 'none'; // Esconde a sele√ß√£o de armas
            isChoosingWeapon = false; // Reseta a flag
            isLevelingUp = false; // Reseta a flag de level up
        }

        // Fun√ß√£o para exibir o menu de sele√ß√£o de arma inicial (para o personagem 'teste')
        function showInitialWeaponSelection() {
            isChoosingInitialWeapon = true; // Define a flag
            document.getElementById('character-selection').style.display = 'none'; // Esconde a sele√ß√£o de personagens
            const initialWeaponSelectionDiv = document.getElementById('initial-weapon-selection');
            const initialWeaponListDiv = document.getElementById('initial-weapon-list');
            initialWeaponListDiv.innerHTML = ''; // Limpa armas anteriores
            const allWeaponIds = Object.keys(weapons);
            // Filtra as op√ß√µes de upgrade de ataque b√°sico e as novas op√ß√µes de level-up para o personagem 'teste'
            const initialWeaponsForTeste = allWeaponIds.filter(weaponId => !weaponId.startsWith('basic_attack_level_') && weapons[weaponId].type !== 'level_up_bonus');

            initialWeaponsForTeste.forEach(weaponId => {
                const weapon = weapons[weaponId];
                const weaponCard = document.createElement('div');
                weaponCard.className = 'upgrade-card';
                weaponCard.onclick = () => selectInitialWeapon(weapon); // Atribui o manipulador de clique
                weaponCard.innerHTML = `<span class="upgrade-icon">${weapon.icon}</span><h3>${weapon.name}</h3><p>${weapon.description}</p>`;
                initialWeaponListDiv.appendChild(weaponCard);
            });
            initialWeaponSelectionDiv.style.display = 'block'; // Exibe a sele√ß√£o de arma inicial
        }

        // Fun√ß√£o para selecionar a arma inicial para o personagem 'teste'
        function selectInitialWeapon(weapon) {
            // Adiciona a arma inicial escolhida
            const newActiveWeapon = {
                id: weapon.id,
                name: weapon.name,
                cooldown: weapon.cooldown,
                lastActivatedTime: 0,
                duration: weapon.duration || 0,
                isActive: false,
                type: weapon.type,
                trigger: weapon.trigger.bind(weapon),
                projectileProps: weapon.projectileProps ? { ...weapon.projectileProps } : null,
                onEnd: weapon.onEnd ? weapon.onEnd.bind(weapon) : null
            };
            player.activeWeapons.push(newActiveWeapon);
            if (newActiveWeapon.type === 'permanent_effect') {
                newActiveWeapon.trigger(player, performance.now(), enemies, projectiles, activeAuras, explosions, experienceOrbs);
            }
            document.getElementById('initial-weapon-selection').style.display = 'none'; // Esconde a sele√ß√£o de arma inicial
            isChoosingInitialWeapon = false; // Reseta a flag
            initGame(); // Inicializa o jogo
        }

        // Fun√ß√£o para lidar com o level up do jogador
        function levelUp() {
            currentLevel++; // Aumenta o n√≠vel
            currentExperience -= experienceToNextLevel; // Deduz o XP necess√°rio para o level up
            experienceToNextLevel = Math.floor(experienceToNextLevel * 1.2); // Aumenta o XP necess√°rio para o pr√≥ximo n√≠vel
            updateGameInfoUI(); // Atualiza a UI
            isLevelingUp = true; // Define a flag para pausar o jogo e exibir o menu de level up
            showMessageBox('N√≠vel Atingido!', `Chegou ao N√≠vel ${currentLevel}! Escolha uma melhoria de atributo:`, 'Escolher Atributo', showUpgradeSelection);
        }

        // Fun√ß√£o para exibir o menu de sele√ß√£o de personagens
        function showCharacterSelection() {
            hideMessageBox(); // Esconde qualquer caixa de mensagem ativa
            const charSelectionDiv = document.getElementById('character-selection');
            const charListDiv = document.getElementById('character-list');
            charListDiv.innerHTML = ''; // Limpa personagens anteriores
            for (const charId in characters) {
                const char = characters[charId];
                const charCard = document.createElement('div');
                charCard.className = 'character-card';
                charCard.onclick = () => { selectCharacter(char); }; // Atribui o manipulador de clique

                // Verifica se a sprite sheet √© usada para este personagem
                if (char.spriteSheetUrl) {
                    const img = assetLoader.getImage(`${char.id}_sheet`);
                    if (img && char.spriteFrames && char.spriteFrames.down) {
                        // Usa o quadro 'down' para exibi√ß√£o na sele√ß√£o de personagem
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = char.spriteWidth;
                        tempCanvas.height = char.spriteHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.imageSmoothingEnabled = false;
                        const frame = char.spriteFrames.down;
                        tempCtx.drawImage(img, frame.sx, frame.sy, frame.sWidth, frame.sHeight, 0, 0, char.spriteWidth, char.spriteHeight);
                        charCard.innerHTML = `<img src="${tempCanvas.toDataURL()}" alt="${char.name}" style="width: 48px; height: 48px; margin-bottom: 5px; image-rendering: pixelated;"><h3>${char.name}</h3><p>${char.description}</p>`;
                    } else {
                        // Fallback para emoji se a sprite sheet for especificada, mas os dados do quadro estiverem faltando ou a imagem n√£o for carregada
                        charCard.innerHTML = `<span class="char-icon">${char.icon}</span><h3>${char.name}</h3><p>${char.description}</p>`;
                    }
                } else {
                    // Fallback para √≠cone emoji se nenhuma sprite sheet for especificada
                    charCard.innerHTML = `<span class="char-icon">${char.icon}</span><h3>${char.name}</h3><p>${char.description}</p>`;
                }
                charListDiv.appendChild(charCard);
            }
            charSelectionDiv.style.display = 'block'; // Exibe a sele√ß√£o de personagens
        }

        // Fun√ß√£o para selecionar um personagem
        function selectCharacter(char) {
            selectedCharacter = char; // Define o personagem selecionado globalmente
            document.getElementById('character-selection').style.display = 'none'; // Esconde a sele√ß√£o de personagens

            // Inicializa o n√≠vel de ataque b√°sico com base no personagem
            if (selectedCharacter.id !== 'teste') {
                player.basicAttackLevel = 1;
            } else {
                player.basicAttackLevel = 0; // O personagem de teste n√£o usa escalonamento de n√≠vel de ataque b√°sico
            }

            // Se o personagem "Teste" for selecionado, exibe a sele√ß√£o de arma inicial
            if (selectedCharacter.id === 'teste') {
                showInitialWeaponSelection();
            } else {
                initGame(); // Caso contr√°rio, inicializa o jogo diretamente
            }
        }

        // Fun√ß√£o para inicializar ou resetar o estado do jogo
        function initGame() {
            // Redefine a posi√ß√£o e propriedades do jogador com base no personagem selecionado
            player.x = mapWidth / 2; // Posi√ß√£o central do mapa
            player.y = mapHeight / 2; // Posi√ß√£o central do mapa
            player.speed = selectedCharacter.playerSpeed; // Define a velocidade do jogador baseada no personagem
            player.color = selectedCharacter.playerColor; // Ser√° undefined se o personagem usar sprite sheet
            player.health = 100;
            player.maxHealth = 100;
            player.damageMultiplier = 1.0;
            player.collectionRadiusMultiplier = 1.0;
            player.baseProjectileDamage = 5;
            player.projectileCountMultiplier = 1; // Isso agora se aplica a outras armas, n√£o √† contagem de ataque b√°sico
            // player.basicAttackLevel j√° √© definido em selectCharacter

            player.useSprite = false;
            player.spriteSheet = null; // Garante que a refer√™ncia da sprite sheet seja nula at√© ser carregada
            player.direction = 'down';
            player.movementAngle = Math.PI / 2; // Define o √¢ngulo inicial para baixo (direita √© 0)
            player.isMoving = false;

            // Reinicia propriedades da habilidade heroica
            player.heroicCharge = 0;
            player.lastHeroicChargeTime = 0;
            player.isHeroicAbilityActive = false;
            player.heroicAbilityEndTime = 0;

            // Reseta as propriedades de invulnerabilidade
            player.isInvulnerable = false;
            player.invulnerabilityStartTime = 0;

            // Carrega a sprite sheet do personagem se dispon√≠vel
            if (selectedCharacter.spriteSheetUrl) {
                player.spriteSheet = assetLoader.getImage(`${selectedCharacter.id}_sheet`); // Obt√©m a imagem da sprite sheet carregada
                if (player.spriteSheet) {
                    player.spriteWidth = selectedCharacter.spriteWidth;
                    player.spriteHeight = selectedCharacter.spriteHeight;
                    player.useSprite = true; // Habilita a renderiza√ß√£o da sprite
                }
            }

            // Limpa as armas ativas, a menos que o personagem 'teste' tenha sido selecionado (que j√° escolheu uma)
            if (selectedCharacter.id !== 'teste') {
                player.activeWeapons = [];
            }
            player.hasShield = false;
            player.lastShieldUsedTime = 0;

            // Limpa todas as entidades do jogo
            projectiles = [];
            enemies = [];
            experienceOrbs = [];
            activeAuras = [];
            explosions = [];

            // Redefine as estat√≠sticas do jogo
            score = 0;
            currentExperience = 0;
            currentLevel = 1;
            experienceToNextLevel = 100;

            // Redefine as flags de estado do jogo
            isLevelingUp = false;
            isChoosingWeapon = false;
            isChoosingInitialWeapon = false;

            // Redefine temporizadores e par√¢metros de spawn de inimigos
            lastBasicAttackTime = 0; // Usado para o cooldown do ataque b√°sico
            lastEnemySpawnInterval = 0;
            enemySpawnInterval = 800;
            enemySpeed = 1; // Redefine a velocidade do inimigo para o valor inicial

            // Inicializa o rastreamento de tempo para o aumento de velocidade dos inimigos
            gameStartTime = performance.now();
            lastTimeBasedSpeedIncrease = gameStartTime;

            // Guarda as propriedades originais para as habilidades heroicas que as modificam
            // Certifica-se de que selectedCharacter e suas propriedades est√£o definidas antes de acess√°-las
            player.originalBasicAttackInterval = selectedCharacter.baseAttackInterval;
            player.originalProjectileCountMultiplier = player.projectileCountMultiplier;
            player.originalProjectileSpeed = selectedCharacter.projectileSpeed;
            player.originalProjectileLifespan = selectedCharacter.projectileLifespan || 0; // Thorne's projectiles might not have a base lifespan
            player.originalProjectileRadius = selectedCharacter.baseProjectileRadius;
            player.originalEnemySpeed = enemySpeed;
            player.originalBasicProjectileDamage = player.baseProjectileDamage;


            updateGameInfoUI(); // Atualiza a UI com as estat√≠sticas iniciais
            gameRunning = true; // Define o jogo como rodando
        }

        /**
         * Desenha uma aura transl√∫cida ao redor do jogador para indicar o raio de coleta.
         * @param {number} x Posi√ß√£o X do centro da aura (jogador).
         * @param {number} y Posi√ß√£o Y do centro da aura (jogador).
         * @param {number} baseRadius Raio base do jogador.
         * @param {number} multiplier Multiplicador do raio de coleta.
         * @param {string} color Cor hexadecimal da aura (ex: '#00FFFF').
         */
        function drawCollectionRadiusAura(x, y, baseRadius, multiplier, color) {
            const auraRadius = baseRadius * multiplier;
            const drawX = x - cameraX;
            const drawY = y - cameraY;

            // Converter cor hexadecimal para RGB para usar em rgba()
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);

            ctx.beginPath();
            ctx.arc(drawX, drawY, auraRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.25)`; // Aura transl√∫cida
            ctx.fill();
            ctx.closePath();

            // Contorno da aura
            ctx.beginPath();
            ctx.arc(drawX, drawY, auraRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`; // Contorno um pouco mais vis√≠vel
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.closePath();
        }

        // Fun√ß√£o para desenhar o jogador no canvas
        function drawPlayer() {
            ctx.imageSmoothingEnabled = false; // Para que a arte em pixel apare√ßa n√≠tida

            // Ajusta a posi√ß√£o de desenho do jogador pela c√¢mera
            const drawX = player.x - cameraX;
            const drawY = player.y - cameraY;

            // L√≥gica de piscar para invulnerabilidade
            if (player.isInvulnerable && Math.floor(performance.now() / 100) % 2 === 0) {
                // Se invulner√°vel e no "quadro" certo, n√£o desenha o jogador (ou desenha transparente)
                ctx.globalAlpha = 0;
            }

            // Verifica se o personagem usa sprite e se a sprite sheet foi carregada
            if (player.useSprite && player.spriteSheet && selectedCharacter.spriteFrames) {
                const frame = selectedCharacter.spriteFrames[player.direction];
                if (frame) {
                    ctx.drawImage(
                        player.spriteSheet,
                        frame.sx, frame.sy, frame.sWidth, frame.sHeight,
                        drawX - player.spriteWidth / 2, drawY - player.spriteHeight / 2,
                        player.spriteWidth, player.spriteHeight
                    );
                } else {
                    console.warn(`No sprite frame defined for direction: ${player.direction} for character ${selectedCharacter.id}`);
                    // Fallback para c√≠rculo se a sprite n√£o puder ser desenhada
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, player.radius, 0, Math.PI * 2);
                    ctx.fillStyle = player.color; // Usa a cor padr√£o do personagem ou fallback
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                }
            } else {
                // Fallback padr√£o se n√£o usar sprite ou n√£o houver sprite sheet
                ctx.beginPath();
                ctx.arc(drawX, drawY, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
            }

            ctx.globalAlpha = 1; // Sempre reseta o alpha para 1 ap√≥s desenhar o jogador

            // Desenha o efeito de escudo se ativo
            if (player.hasShield) {
                ctx.beginPath();
                ctx.arc(drawX, drawY, player.radius + 10, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                ctx.lineWidth = 5;
                ctx.stroke();
                ctx.closePath();
            }

            // Desenha a seta de dire√ß√£o do jogador
            ctx.save(); // Salva o estado atual do canvas
            ctx.translate(drawX, drawY); // Move a origem para o centro do jogador

            // Obt√©m o √¢ngulo de movimento atual do jogador
            // Se o jogador n√£o estiver se movendo, a seta mant√©m a √∫ltima dire√ß√£o ou a padr√£o (para baixo)
            let arrowAngle = player.movementAngle;

            ctx.rotate(arrowAngle); // Rotaciona o contexto para o √¢ngulo de movimento

            const arrowDistanceFromPlayer = player.radius + 5; // Dist√¢ncia do centro do jogador at√© a base da seta
            const arrowLength = 15; // Comprimento da linha da seta
            const arrowHeadSize = 8; // Tamanho da base da ponta da seta

            ctx.beginPath();
            // Ponto inicial da linha da seta, deslocado para a "frente" do jogador
            ctx.moveTo(arrowDistanceFromPlayer, 0);
            // Ponto final da linha da seta
            ctx.lineTo(arrowDistanceFromPlayer + arrowLength, 0);

            // Pontos da cabe√ßa da seta
            ctx.lineTo(arrowDistanceFromPlayer + arrowLength - arrowHeadSize, -arrowHeadSize / 2);
            ctx.moveTo(arrowDistanceFromPlayer + arrowLength, 0); // Volta para a ponta
            ctx.lineTo(arrowDistanceFromPlayer + arrowLength - arrowHeadSize, arrowHeadSize / 2);

            ctx.strokeStyle = 'yellow';
            ctx.fillStyle = 'yellow';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fill(); // Preenche a cabe√ßa da seta

            ctx.restore(); // Restaura o estado do canvas para evitar que outras coisas girem
        }

        // Fun√ß√£o para desenhar proj√©teis no canvas
        function drawProjectiles() {
            projectiles.forEach(p => {
                if (p.creationTime && performance.now() < p.creationTime) {
                    return;
                }

                // Ajusta aposi√ß√£o de desenho do proj√©til pela c√¢mera
                const drawX = p.x - cameraX;
                const drawY = p.y - cameraY;

                if (p.type === 'sprite_projectile' && p.sprite) {
                    ctx.drawImage(p.sprite, drawX - p.width / 2, drawY - p.height / 2, p.width, p.height);
                } else if (p.type === 'laser') {
                    ctx.save(); // Salva o estado atual do canvas
                    // O centro do laser para traduzir deve ser o ponto inicial de onde ele est√° desenhando
                    const laserDrawX = p.x - cameraX;
                    const laserDrawY = p.y - cameraY;

                    ctx.translate(laserDrawX, laserDrawY); // Move a origem para o ponto inicial do laser
                    ctx.rotate(p.angle); // Rotaciona pelo √¢ngulo do proj√©til

                    // Usa a visualLength definida no proj√©til
                    const currentLaserLength = p.visualLength;

                    // Calcula a opacidade para o fade-out
                    let alpha = 1;
                    if (p.lifespan !== Infinity) { // Se tiver um lifespan finito, faz fade out
                        const timeElapsed = performance.now() - p.creationTime;
                        // Assuming 60 FPS, lifespan is in frames. Convert to milliseconds.
                        const totalLifespanMs = p.lifespan * (1000 / 60);
                        alpha = Math.max(0, 1 - (timeElapsed / totalLifespanMs));
                    }
                    
                    ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`; // Cor do laser com opacidade ajust√°vel
                    // Desenha um ret√¢ngulo que come√ßa na origem (0, -p.width/2) e se estende por 'currentLaserLength'
                    ctx.fillRect(0, -p.width / 2, currentLaserLength, p.width);
                    ctx.restore(); // Restaura o estado do canvas
                } else if (p.type === 'enemy_projectile') { // Novo tipo de proj√©til para inimigos atiradores
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    ctx.closePath();
                }
                else {
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    if (p.type === 'orbiting') {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    ctx.closePath();
                }
            });
        }

        // Fun√ß√£o para desenhar inimigos no canvas
        function drawEnemies() {
            enemies.forEach(e => {
                // Ajusta a posi√ß√£o de desenho do inimigo pela c√¢mera
                const drawX = e.x - cameraX;
                const drawY = e.y - cameraY;

                ctx.beginPath();
                ctx.arc(drawX, drawY, e.radius, 0, Math.PI * 2);
                ctx.fillStyle = e.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                // Se for um inimigo atirador, desenha uma borda diferente
                if (e.type === 'shooter') {
                    ctx.strokeStyle = 'rgba(0, 0, 255, 0.8)'; // Borda azul para atiradores
                }
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();

                const barWidth = e.radius * 2 * 0.8;
                const barHeight = 4;
                const barX = drawX - barWidth / 2;
                const barY = drawY - e.radius - 8;
                ctx.fillStyle = '#555';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                const healthPercentage = e.health / e.maxHealth;
                let barColor = 'lime';
                if (healthPercentage < 0.6) barColor = 'yellow';
                if (healthPercentage < 0.3) barColor = 'red';
                ctx.fillStyle = barColor;
                ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            });
        }

        // Fun√ß√£o para desenhar a barra de vida do jogador
        function drawHealthBar(x, y, currentHealth, maxHealth) {
            // Ajusta aposi√ß√£o de desenho da barra de vida pela c√¢mera
            const drawX = x - cameraX;
            const drawY = y - cameraY;

            const barWidth = 40;
            const barHeight = 6;
            const yOffset = player.useSprite ? player.spriteHeight / 2 : player.radius;
            const barX = drawX - barWidth / 2;
            const barY = drawY - yOffset - 15; // 15 pixels acima da borda superior do jogador
            ctx.fillStyle = '#555';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            const healthPercentage = currentHealth / maxHealth;
            const currentBarWidth = barWidth * healthPercentage;
            if (healthPercentage > 0.6) { ctx.fillStyle = '#0F0'; } else if (healthPercentage > 0.3) { ctx.fillStyle = '#FFD700'; } else { ctx.fillStyle = '#F00'; }
            ctx.fillRect(barX, barY, currentBarWidth, barHeight);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        // Fun√ß√£o para desenhar a barra de habilidade heroica
        function drawHeroicBar() {
            // Ajusta a posi√ß√£o de desenho do jogador pela c√¢mera
            const drawX = player.x - cameraX;
            const drawY = player.y - cameraY;

            const barWidth = 40; // Mant√©m a largura consistente com a barra de vida
            const barHeight = 6; // Mant√©m a altura consistente com a barra de vida

            // Calcula o offset visual do topo do jogador (seja raio ou sprite height)
            const player_visual_top_offset = player.useSprite ? player.spriteHeight / 2 : player.radius;

            // Posi√ß√£o Y da barra de vida (topo)
            const health_bar_y_top = drawY - player_visual_top_offset - 15;
            // Posi√ß√£o Y da barra de vida (base)
            const health_bar_y_bottom = health_bar_y_top + 6; // Health bar height is 6

            // Posi√ß√£o Y da barra heroica: um pequeno espa√ßo abaixo da barra de vida
            const small_gap_between_bars = 2;
            const heroicBarY = health_bar_y_bottom + small_gap_between_bars;

            // Posi√ß√£o X da barra heroica (centralizada com o jogador)
            const heroicBarX = drawX - barWidth / 2;

            ctx.fillStyle = '#555'; // Fundo da barra
            ctx.fillRect(heroicBarX, heroicBarY, barWidth, barHeight);

            const chargePercentage = player.heroicCharge / player.maxHeroicCharge;
            let barColor = '#00BFFF'; // Cor azul para a barra
            if (chargePercentage >= 1) {
                barColor = '#FFD700'; // Dourado quando carregada
            }
            ctx.fillStyle = barColor;
            ctx.fillRect(heroicBarX, heroicBarY, barWidth * chargePercentage, barHeight);

            ctx.strokeStyle = '#eee'; // Borda da barra
            ctx.lineWidth = 1;
            ctx.strokeRect(heroicBarX, heroicBarY, barWidth, barHeight);
        }

        // Fun√ß√£o para desenhar orbes de experi√™ncia
        function drawExperienceOrbs() {
            experienceOrbs.forEach(orb => {
                // Ajusta a posi√ß√£o de desenho do orbe pela c√¢mera
                const drawX = orb.x - cameraX;
                const drawY = orb.y - cameraY;

                ctx.beginPath();
                ctx.arc(drawX, drawY, orb.radius, 0, Math.PI * 2);
                ctx.fillStyle = orb.color;
                ctx.fill();
                ctx.closePath();
            });
        }

        // Fun√ß√£o para desenhar v√°rios efeitos de jogo (explos√µes, auras)
        function drawEffects() {
            explosions.forEach(effect => {
                // Ajusta aposi√ß√£o de desenho do efeito pela c√¢mera
                const drawX = effect.x - cameraX;
                const drawY = effect.y - cameraY;

                ctx.beginPath();
                if (effect.type === 'flash') {
                    ctx.arc(drawX, drawY, effect.radius, 0, Math.PI * 2);
                    ctx.fillStyle = effect.color;
                    ctx.globalAlpha = effect.alpha || 1;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (effect.type === 'explosion') {
                    ctx.arc(drawX, drawY, effect.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.7)'; // Cor da explos√£o
                    ctx.fill();
                }
                ctx.closePath();
            });
            activeAuras.forEach(aura => {
                // Auras s√£o desenhadas em rela√ß√£o √† posi√ß√£o do jogador
                const auraDrawX = player.x - cameraX;
                const auraDrawY = player.y - cameraY;
                if (aura.type === 'timed_aura_damage') {
                    ctx.beginPath();
                    ctx.arc(auraDrawX, auraDrawY, aura.visualRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = aura.color;
                    ctx.lineWidth = 5;
                    ctx.globalAlpha = 0.5;
                    ctx.stroke();
                    ctx.fillStyle = `rgba(0, 0, 139, 0.2)`;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.closePath();
                }
            });
        }

        // Constantes para os par√¢metros do proj√©til "sanfonado" do Kazu
        const KAZU_ACCORDION_AMPLITUDE = 30; // Amplitude da onda (pixels de lado a lado)
        const KAZU_ACCORDION_FREQUENCY = 0.02; // Frequ√™ncia da onda (quanto maior, mais "dobras" na trajet√≥ria)


        /**
         * Cria e retorna um objeto de proj√©til base para o jogador, com base no personagem selecionado.
         * Esta fun√ß√£o encapsula a l√≥gica espec√≠fica de cada personagem para seu proj√©til principal.
         * @param {object} playerRef A refer√™ncia ao objeto do jogador.
         * @param {object} selectedChar A refer√™ncia ao objeto do personagem selecionado.
         * @param {number} baseDamage O dano base a ser aplicado (j√° multiplicado).
         * @param {number} scaledRadius O raio do proj√©til ajustado pelo n√≠vel de ataque b√°sico.
         * @param {number} angle O √¢ngulo de disparo do proj√©til.
         * @returns {object} O objeto do proj√©til com suas propriedades iniciais.
         */
        function createBasePlayerProjectile(playerRef, selectedChar, baseDamage, scaledRadius, angle) {
            let projectileProps = {
                x: playerRef.x, y: playerRef.y,
                radius: scaledRadius,
                speed: selectedChar.projectileSpeed, // Velocidade ajustada pela Destreza
                color: selectedChar.projectileColor,
                damage: baseDamage,
                dx: Math.cos(angle),
                dy: Math.sin(angle),
                type: 'normal', // Tipo padr√£o
                lifespan: selectedChar.projectileLifespan, // Lifespan base do personagem
            };

            switch (selectedChar.id) {
                case 'andywn':
                    projectileProps.type = 'sprite_projectile';
                    projectileProps.sprite = assetLoader.getImage(`${selectedChar.id}_projectile`);
                    projectileProps.width = selectedChar.projectileSpriteWidth * (scaledRadius / selectedChar.baseProjectileRadius);
                    projectileProps.height = selectedChar.projectileSpriteHeight * (scaledRadius / selectedChar.baseProjectileRadius);
                    break;
                case 'kazu':
                    projectileProps.initialX = playerRef.x;
                    projectileProps.initialY = playerRef.y;
                    projectileProps.initialAngle = angle; // Usa o √¢ngulo passado
                    projectileProps.amplitude = KAZU_ACCORDION_AMPLITUDE;
                    projectileProps.frequency = KAZU_ACCORDION_FREQUENCY;
                    projectileProps.type = 'kazu_accordion_projectile';
                    projectileProps.lifespan = Infinity; // Proj√©til Kazu sempre infinito
                    break;
                case 'raime':
                    projectileProps.type = 'melee';
                    projectileProps.initialX = playerRef.x;
                    projectileProps.initialY = playerRef.y;
                    projectileProps.maxTravelDistance = selectedChar.projectileMaxTravelDistance;
                    break;
                case 'thorne':
                    projectileProps.type = 'normal'; // O tratamento de m√∫ltiplos √© feito fora
                    break;
                case 'general':
                    projectileProps.type = 'normal'; // O tratamento de m√∫ltiplos √© feito fora
                    break;
                case 'ito':
                    const randomBaseRadius = selectedChar.projectileMinRadius + (Math.random() * (selectedChar.projectileMaxRadius - selectedChar.projectileMinRadius));
                    projectileProps.radius = randomBaseRadius * (1 + (playerRef.basicAttackLevel - 1) * 0.05); // Rescale for level
                    break;
            }
            return projectileProps;
        }


        // Fun√ß√£o para lidar com o spawn do proj√©til prim√°rio do jogador (ataque b√°sico)
        function spawnProjectile(currentTime) {
            // S√≥ dispara se o personagem n√£o for 'teste' e o cooldown for atendido
            if (selectedCharacter.id !== 'teste' && (currentTime - lastBasicAttackTime > selectedCharacter.baseAttackInterval)) {
                lastBasicAttackTime = currentTime;

                const baseRadius = selectedCharacter.baseProjectileRadius;
                const scaledRadius = baseRadius * (1 + (player.basicAttackLevel - 1) * 0.05);
                const baseDamage = selectedCharacter.baseProjectileDamage * player.damageMultiplier; // Dano do personagem

                let projectilesToSpawnThisFrame = [];

                // L√≥gica espec√≠fica para o ataque de RAIM√â
                if (selectedCharacter.id === 'raime') {
                    const numPunches = 5; // 5 proj√©teis para Raim√©
                    const arcAngle = Math.PI * 0.8; // 180 graus de arco (ajustado para ser um pouco mais estreito)
                    const initialAngle = player.movementAngle - (arcAngle / 2); // Come√ßa do centro do arco para a esquerda

                    for (let j = 0; j < numPunches; j++) {
                        const spreadAngle = initialAngle + (j * arcAngle / (numPunches - 1));
                        const raimeProjectile = createBasePlayerProjectile(player, selectedCharacter, baseDamage, scaledRadius, spreadAngle);
                        raimeProjectile.creationTime = currentTime; // Sem atraso entre os socos em arco
                        projectilesToSpawnThisFrame.push(raimeProjectile);
                    }
                    projectiles.push(...projectilesToSpawnThisFrame);
                    return; // Retorna para n√£o processar o loop padr√£o de ataque b√°sico
                }


                // L√≥gica padr√£o para outros personagens que usam basicAttackLevel para n√∫mero de proj√©teis
                for (let i = 0; i < player.basicAttackLevel; i++) {
                    const delay = i * 500; // 0.5 seconds delay per extra projectile
                    const projectileCreationTime = currentTime + delay;

                    let currentProjectileProps = createBasePlayerProjectile(player, selectedCharacter, baseDamage, scaledRadius, player.movementAngle); // Usa o √¢ngulo de movimento do jogador

                    // Ajustes de √¢ngulo para ataques que disparam em leque/m√∫ltiplos (Thorne, General)
                    if (selectedCharacter.id === 'thorne') {
                        const diagonalAngles = [0, Math.PI / 4, Math.PI / 2, 3 * Math.PI / 4, Math.PI, 5 * Math.PI / 4, 3 * Math.PI / 2, 7 * Math.PI / 4]; // Todas as 8 dire√ß√µes
                        // Thorne fires his 4 diagonals as his *base* attack. basicAttackLevel affects properties, not count.
                        // We will always fire 4 fixed diagonals from Thorne. The loop of basicAttackLevel is used here to trigger
                        // the multiplier multiple times, and give the visual combo effect by increasing properties of the projectiles
                        // not increasing the count.
                        // To achieve 4 separate simultaneous projectiles, this logic needs to be outside and separate.
                        if (i === 0) { // Only for the first conceptual "projectile" of the basic attack sequence
                            const fixedThorneAngles = [Math.PI / 4, 3 * Math.PI / 4, 5 * Math.PI / 4, 7 * Math.PI / 4];
                            fixedThorneAngles.forEach(angle => {
                                let thorneProj = createBasePlayerProjectile(player, selectedCharacter, baseDamage, scaledRadius, angle);
                                thorneProj.dx = Math.cos(angle);
                                thorneProj.dy = Math.sin(angle);
                                thorneProj.creationTime = projectileCreationTime;
                                thorneProj.type = 'penetrating'; // Thorne's attacks penetrate
                                thorneProj.lifespan = Infinity; // Thorne's attacks penetrate

                                projectilesToSpawnThisFrame.push(thorneProj);
                            });
                            continue; // Skip the default push below for Thorne if we handled his attack pattern here
                        }
                    } else if (selectedCharacter.id === 'general') {
                        const numShots = 3;
                        const fanAngle = Math.PI / 8;
                        const spread = player.movementAngle - (fanAngle / 2) + (i * fanAngle / (numShots - 1));
                        currentProjectileProps.dx = Math.cos(spread);
                        currentProjectileProps.dy = Math.sin(spread);
                    }

                    currentProjectileProps.creationTime = projectileCreationTime; // Set creation time for this individual projectile
                    projectilesToSpawnThisFrame.push(currentProjectileProps);
                }

                // Add all generated projectiles to the main projectiles array
                projectiles.push(...projectilesToSpawnThisFrame);
            }
        }

        // Fun√ß√£o para lidar com o spawn de inimigos
        function spawnEnemy(currentTime) {
            // Se Gaeru estiver com habilidade heroica, n√£o spawna inimigos (paralisa)
            if (selectedCharacter.id === 'gaeru' && player.isHeroicAbilityActive) {
                return;
            }

            if (currentTime - lastEnemySpawnTime > enemySpawnInterval) {
                let x, y;
                // Determine se vai spawnar um inimigo atirador ou padr√£o
                if (Math.random() < 0.25) { // 25% de chance para atirador
                    // Inimigos atiradores spawnam dentro da tela vis√≠vel do jogador
                    x = player.x - (canvas.width / 2) + Math.random() * canvas.width;
                    y = player.y - (canvas.height / 2) + Math.random() * canvas.height;

                    // Garante que a vida e o dano escalem com o n√≠vel do jogador
                    const shooterHealth = shooterEnemyProps.health + (currentLevel * 5); // Vida base + n√≠vel * 5 (ATUALIZADO)
                    const shooterProjectileDamage = shooterEnemyProps.projectileDamage + (currentLevel * 3); // Dano base + n√≠vel * 3 (ATUALIZADO)

                    enemies.push({
                        x: x,
                        y: y,
                        radius: shooterEnemyProps.radius,
                        speed: 0, // Inimigo atirador n√£o se move
                        color: shooterEnemyProps.color,
                        health: shooterHealth,
                        maxHealth: shooterHealth,
                        type: 'shooter', // Marca como inimigo atirador
                        attackInterval: shooterEnemyProps.attackInterval,
                        lastAttackTime: currentTime,
                        projectileDamage: shooterProjectileDamage, // Dano escalado (ATUALIZADO)
                        projectileRadius: shooterEnemyProps.projectileRadius,
                        projectileSpeed: shooterEnemyProps.projectileSpeed,
                        projectileLifespan: shooterEnemyProps.projectileLifespan // Define o lifespan do proj√©til do atirador
                    });
                } else { // 75% de chance para inimigo padr√£o
                    const padding = 50;
                    const side = Math.floor(Math.random() * 4);
                    // L√≥gica de spawn para inimigos padr√µes (fora do mapa)
                    switch (side) {
                        case 0: x = Math.random() * mapWidth; y = -padding; break; // Topo do mapa
                        case 1: x = mapWidth + padding; y = Math.random() * mapHeight; break; // Direita do mapa
                        case 2: x = Math.random() * mapWidth; y = mapHeight + padding; break; // Fundo do mapa
                        case 3: x = -padding; y = Math.random() * mapHeight; break; // Esquerda do mapa
                    }
                    const enemyInitialHealth = 10 + (currentLevel * 2) + (Math.floor(Math.random() * 20) + 1);
                    const enemyCurrentSpeed = enemySpeed * ((Math.random() * 1.4 + 0.1));
                    let enemyCurrentRadius = player.radius * ((Math.random() * 2.95) + 0.05);
                    enemies.push({ x: x, y: y, radius: enemyCurrentRadius, speed: enemyCurrentSpeed, color: 'red', health: enemyInitialHealth, maxHealth: enemyInitialHealth, type: 'standard' });
                }

                lastEnemySpawnTime = currentTime;
                if (enemySpawnInterval > 250) enemySpawnInterval -= 5;
            }
        }

        // L√≥gica principal de atualiza√ß√£o do jogo
        function update(currentTime) {
            // Pausa a atualiza√ß√£o se o jogo n√£o estiver rodando ou um menu estiver aberto
            if (!gameRunning || isLevelingUp || isChoosingWeapon || isChoosingInitialWeapon) return;

            // L√≥gica da Habilidade Heroica Ativa
            if (player.isHeroicAbilityActive && currentTime >= player.heroicAbilityEndTime) {
                player.isHeroicAbilityActive = false;
                // Chama a fun√ß√£o onHeroicAbilityEnd se ela existir para o personagem selecionado
                if (selectedCharacter.onHeroicAbilityEnd) {
                    selectedCharacter.onHeroicAbilityEnd(player);
                }
                console.log(`Habilidade Heroica de ${selectedCharacter.name} terminou.`);
            }

            // Aplica o aumento de velocidade dos inimigos baseado no tempo
            if (currentTime - lastTimeBasedSpeedIncrease >= TIME_INTERVAL_FOR_SPEED_INCREASE) {
                enemySpeed *= (1 + SPEED_INCREASE_PERCENTAGE);
                lastTimeBasedSpeedIncrease = currentTime;
            }

            // L√≥gica de invulnerabilidade do jogador
            if (player.isInvulnerable && (currentTime - player.invulnerabilityStartTime) >= player.invulnerabilityDuration) {
                player.isInvulnerable = false; // Desativa invulnerabilidade
            }

            let dx = 0, dy = 0;
            if (keys.w) dy -= 1;
            if (keys.s) dy += 1;
            if (keys.a) dx -= 1;
            if (keys.d) dx += 1;

            player.isMoving = (dx !== 0 || dy !== 0);
            if (player.isMoving) {
                // Atualiza o √¢ngulo de movimento para a seta direcional
                player.movementAngle = Math.atan2(dy, dx);

                // L√≥gica de dire√ß√£o para sprite (mant√©m para anima√ß√£o de sprite, se aplic√°vel)
                if (Math.abs(dx) > Math.abs(dy)) { // Movimento horizontal √© mais dominante
                    player.direction = (dx < 0) ? 'left' : 'right';
                } else { // Movimento vertical √© mais dominante ou igual
                    player.direction = (dy < 0) ? 'up' : 'down';
                }

                const len = Math.sqrt(dx * dx + dy * dy);
                const moveAmount = (len === 0) ? 0 : (player.speed / len); // Evita divis√£o por zero
                player.x += dx * moveAmount;
                player.y += dy * moveAmount;
            }

            // Limita a posi√ß√£o do jogador dentro dos limites do MAPA
            player.x = Math.max(player.radius, Math.min(mapWidth - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(mapHeight - player.radius, player.y));

            // Atualiza a posi√ß√£o da c√¢mera para seguir o jogador
            cameraX = player.x - canvas.width / 2;
            cameraY = player.y - canvas.height / 2;

            // Atualiza armas ativas do jogador
            player.activeWeapons.forEach(weapon => {
                if (weapon.type === 'passive_effect') {
                    if (!player.hasShield && (currentTime - player.lastShieldUsedTime) >= weapon.cooldown) {
                        player.hasShield = true;
                    }
                }
                else if (weapon.type !== 'permanent_effect' && weapon.type !== 'basic_attack_level_up' && weapon.type !== 'level_up_bonus' && (currentTime - weapon.lastActivatedTime) >= weapon.cooldown) {
                    weapon.trigger(player, currentTime, enemies, projectiles, activeAuras, explosions, experienceOrbs);
                    weapon.lastActivatedTime = currentTime;
                }
            });

            // L√≥gica de ataque para inimigos atiradores
            enemies.forEach(enemy => {
                if (enemy.type === 'shooter') {
                    if (currentTime - enemy.lastAttackTime > enemy.attackInterval) {
                        // Atirador dispara um proj√©til em dire√ß√£o ao jogador
                        const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        const dx_proj_enemy = Math.cos(angleToPlayer);
                        const dy_proj_enemy = Math.sin(angleToPlayer);

                        projectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            radius: enemy.projectileRadius,
                            speed: enemy.projectileSpeed,
                            color: 'orange', // Cor do proj√©til do atirador
                            damage: enemy.projectileDamage, // Dano escalado do atirador
                            dx: dx_proj_enemy,
                            dy: dy_proj_enemy,
                            type: 'enemy_projectile', // Novo tipo para proj√©teis de inimigos
                            lifespan: enemy.projectileLifespan, // Usa o lifespan do atirador (ATUALIZADO)
                            creationTime: currentTime
                        });
                        enemy.lastAttackTime = currentTime;
                    }
                } else {
                    // Move inimigo padr√£o em dire√ß√£o ao jogador no MAPA (l√≥gica existente)
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.x += Math.cos(angle) * enemy.speed;
                    enemy.y += Math.sin(angle) * enemy.speed;
                }
            });

            // Atualiza e filtra auras ativas
            activeAuras = activeAuras.filter(effect => {
                if (effect.endTime && currentTime >= effect.endTime) {
                    if(effect.onEnd) effect.onEnd(player);
                    return false;
                }
                if (effect.type === 'timed_aura_damage' && currentTime >= effect.nextDamageTime) {
                    enemies.forEach((enemy) => {
                        // Colis√£o da aura agora considera a posi√ß√£o relativa do inimigo ao jogador (centro da aura)
                        const distance = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                        if (distance < effect.radius + enemy.radius) {
                            enemy.health -= effect.damage * player.damageMultiplier;
                            if (enemy.health <= 0) {
                                enemiesToRemove.add(enemy);
                                score += Math.round(10 * player.damageMultiplier);
                                orbsToSpawn.push({ x: enemy.x, y: enemy.y, radius: 8, color: 'lightgreen', value: 10 });
                                // Adiciona carga heroica ao matar (para auras tamb√©m)
                                if (player.heroicCharge < player.maxHeroicCharge) {
                                    player.heroicCharge += player.heroicChargePerKill;
                                    player.heroicCharge = Math.min(player.heroicCharge, player.maxHeroicCharge);
                                }
                            }
                        }
                    });
                    effect.nextDamageTime = currentTime + effect.tickInterval;
                }
                return true;
            });

            // Atualiza e filtra proj√©teis
            projectiles = projectiles.filter(p => {
                // Remove proj√©teis que j√° foram marcados para remo√ß√£o
                if (projectilesToRemove.has(p)) {
                    return false;
                }

                if (p.creationTime && performance.now() < p.creationTime) {
                    return true;
                }

                // L√≥gica de movimento para proj√©til Kazu Sanfonado
                if (p.type === 'kazu_accordion_projectile') {
                    const elapsedMs = currentTime - p.creationTime;
                    // Converter velocidade de pixels/frame para pixels/ms (aprox. 60 FPS)
                    const speedPerMs = p.speed / (1000 / 60);

                    // Posi√ß√£o linear ao longo da dire√ß√£o inicial
                    const linearX = p.initialX + Math.cos(p.initialAngle) * (speedPerMs * elapsedMs);
                    const linearY = p.initialY + Math.sin(p.initialAngle) * (speedPerMs * elapsedMs);

                    // Offset perpendicular para o efeito sanfonado (onda senoidal)
                    const perpendicularAngle = p.initialAngle + Math.PI / 2;
                    const offsetX = Math.cos(perpendicularAngle) * p.amplitude * Math.sin(elapsedMs * p.frequency);
                    const offsetY = Math.sin(perpendicularAngle) * p.amplitude * Math.sin(elapsedMs * p.frequency);

                    p.x = linearX + offsetX;
                    p.y = linearY + offsetY;

                }
                // FIM L√≥gica Kazu Sanfonado
                else if (p.type === 'orbiting') {
                    p.currentOrbitAngle += p.orbitSpeed;
                    p.x = player.x + Math.cos(p.currentOrbitAngle) * p.orbitRadius;
                    p.y = player.y + Math.sin(p.currentOrbitAngle) * p.orbitRadius;
                }
                else if (p.type === 'figure_eight') {
                    const elapsedTime = currentTime - p.loopStartTime;
                    if (elapsedTime >= p.loopDuration) return false;
                    const timeRatio = elapsedTime / p.loopDuration;
                    const angle = timeRatio * Math.PI * 2;
                    p.x = p.initialX + Math.sin(angle) * p.loopSizeX;
                    p.y = p.initialY + Math.sin(angle * 2) * p.loopSizeY;
                }
                else {
                    p.x += (p.dx || 0) * p.speed;
                    p.y += (p.dy || 0) * p.speed;
                }

                // L√≥gica de tempo de vida (lifespan)
                if (p.lifespan !== undefined && p.lifespan !== Infinity) {
                    p.lifespan--;
                    if (p.lifespan <= 0) {
                        return false; // Remove o proj√©til se o tempo de vida acabar
                    }
                }

                if (p.type === 'bomb') {
                    // Se a bomba explodir por tempo ou colis√£o
                    if (p.fuseTime <= 0 || p.isCollided) {
                        explosions.push({ x: p.x, y: p.y, radius: p.explosionRadius, damage: p.explosionDamage, duration: 15, type: 'explosion' });
                        return false; // Remove a bomba ap√≥s a explos√£o
                    }
                    return true;
                }
                if (p.type === 'melee') {
                    const dist = Math.sqrt((p.x - p.initialX)**2 + (p.y - p.initialY)**2);
                    return dist < p.maxTravelDistance;
                }
                // Proj√©teis (exceto aqueles com lifespan finito j√° tratados) devem ser removidos se sa√≠rem dos limites do MAPA (n√£o da tela vis√≠vel)
                return p.x > -p.radius && p.x < mapWidth + p.radius && p.y > -p.radius && p.y < mapHeight + p.radius;
            });

            // Atualiza e filtra explos√µes
            explosions = explosions.filter(effect => {
                if (effect.type === 'explosion') {
                    enemies.forEach((enemy) => {
                        if (Math.sqrt((effect.x - enemy.x) ** 2 + (effect.y - enemy.y) ** 2) < effect.radius + enemy.radius) {
                            enemy.health -= effect.damage;
                            if (enemy.health <= 0) {
                                enemiesToRemove.add(enemy);
                                score += Math.round(10 * player.damageMultiplier);
                                orbsToSpawn.push({ x: enemy.x, y: enemy.y, radius: 8, color: 'lightgreen', value: 10 });
                                // Adiciona carga heroica ao matar (para explos√µes tamb√©m)
                                if (player.heroicCharge < player.maxHeroicCharge) {
                                    player.heroicCharge += player.heroicChargePerKill;
                                    player.heroicCharge = Math.min(player.heroicCharge, player.maxHeroicCharge);
                                }
                            }
                        }
                    });
                }
                effect.duration--;
                if (effect.type === 'flash') effect.alpha = Math.max(0, (effect.alpha || 1) - 0.2);
                return effect.duration > 0;
            });

            // Carregamento da habilidade heroica por tempo
            if (currentTime - player.lastHeroicChargeTime >= player.heroicChargeInterval) {
                if (player.heroicCharge < player.maxHeroicCharge) {
                    player.heroicCharge += 1; // Aumenta 1 a cada intervalo
                    player.heroicCharge = Math.min(player.heroicCharge, player.maxHeroicCharge);
                }
                player.lastHeroicChargeTime = currentTime;
            }


            // Lida com colis√µes entre proj√©teis e inimigos e proj√©teis inimigos e jogador
            enemies.forEach((enemy) => {
                // Colis√µes proj√©til do jogador - inimigo
                projectiles.forEach((p) => {
                    // Ignora proj√©teis inimigos ao colidir com outros inimigos
                    if (p.type === 'enemy_projectile') return;

                    const projectileEffectiveRadius = p.radius !== undefined ? p.radius : p.width / 2;
                    if (Math.sqrt((p.x - enemy.x) ** 2 + (p.y - enemy.y) ** 2) < projectileEffectiveRadius + enemy.radius) {
                        if (p.type === 'bomb') {
                            if (!p.isCollided) {
                                p.isCollided = true;
                                p.speed = 0;
                                p.fuseTime = 1;
                            }
                            return;
                        }

                        enemy.health -= p.damage;
                        // Proj√©teis perfurantes n√£o s√£o removidos
                        if (!['laser', 'figure_eight', 'melee', 'orbiting', 'sprite_projectile', 'penetrating', 'kazu_accordion_projectile'].includes(p.type)) {
                            projectilesToRemove.add(p);
                        }
                        if (enemy.health <= 0) {
                            enemiesToRemove.add(enemy);
                            score += Math.round(10 * player.damageMultiplier);
                            orbsToSpawn.push({ x: enemy.x, y: enemy.y, radius: 8, color: 'lightgreen', value: 10 });
                            if (player.heroicCharge < player.maxHeroicCharge) {
                                player.heroicCharge += player.heroicChargePerKill;
                                player.heroicCharge = Math.min(player.heroicCharge, player.maxHeroicCharge);
                            }
                            if (p.type === 'leech') player.health = Math.min(player.health + p.damage, player.maxHealth);
                        }
                    }
                });

                // Colis√µes jogador-inimigo (inimigos padr√£o e atiradores)
                if (Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2) < player.radius + enemy.radius) {
                    if (!player.isInvulnerable) {
                        if (player.hasShield) {
                            player.hasShield = false;
                            player.lastShieldUsedTime = currentTime;
                        } else {
                            player.health -= enemyDamageToPlayer; // Dano do inimigo corpo a corpo
                            player.isInvulnerable = true;
                            player.invulnerabilityStartTime = currentTime;
                        }

                        if (player.health <= 0) {
                            gameRunning = false;
                            showMessageBox('Fim de Jogo!', `A sua pontua√ß√£o final: ${score}<br>Foi derrotado.`, 'Jogar Novamente', showCharacterSelection);
                        }
                    }
                }
            });

            // Colis√µes proj√©til do inimigo - jogador
            projectiles.forEach(p => {
                if (p.type === 'enemy_projectile') {
                    if (Math.sqrt((player.x - p.x) ** 2 + (player.y - p.y) ** 2) < player.radius + p.radius) {
                        if (!player.isInvulnerable) {
                            if (player.hasShield) {
                                player.hasShield = false;
                                player.lastShieldUsedTime = currentTime;
                            } else {
                                player.health -= p.damage; // Dano do proj√©til inimigo
                                player.isInvulnerable = true;
                                player.invulnerabilityStartTime = currentTime;
                            }
                            projectilesToRemove.add(p); // Remove o proj√©til inimigo ap√≥s o contato
                            if (player.health <= 0) {
                                gameRunning = false;
                                showMessageBox('Fim de Jogo!', `A sua pontua√ß√£o final: ${score}<br>Foi derrotado.`, 'Jogar Novamente', showCharacterSelection);
                            }
                        }
                    }
                }
            });


            experienceOrbs.push(...orbsToSpawn);
            orbsToSpawn = [];
            projectiles = projectiles.filter(p => !projectilesToRemove.has(p));
            projectilesToRemove.clear();
            enemies = enemies.filter(e => !enemiesToRemove.has(e));
            enemiesToRemove.clear();

            experienceOrbs = experienceOrbs.filter(orb => {
                // Colis√£o do orbe com o raio de coleta do jogador
                if (Math.sqrt((player.x - orb.x) ** 2 + (player.y - orb.y) ** 2) < player.radius * player.collectionRadiusMultiplier + orb.radius) {
                    currentExperience += orb.value;
                    return false;
                }
                return true;
            });

            if (currentExperience >= experienceToNextLevel) {
                levelUp();
                if (isLevelingUp) return;
            }

            updateGameInfoUI();
            spawnProjectile(currentTime);
            spawnEnemy(currentTime);
        }

        // L√≥gica principal de desenho do jogo
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas

            // Desenha a imagem de fundo do mapa
            const backgroundMapImage = assetLoader.getImage('background_map');
            if (backgroundMapImage) {
                ctx.imageSmoothingEnabled = false; // Garante que a arte em pixel fique n√≠tida
                ctx.drawImage(backgroundMapImage,
                                0, 0, backgroundMapImage.width, backgroundMapImage.height, // Ret√¢ngulo de origem (a imagem inteira)
                                -cameraX, -cameraY, mapWidth, mapHeight); // Ret√¢ngulo de destino (preenche o mapa e se move com a c√¢mera)
            }

            drawExperienceOrbs(); // Desenha orbes
            drawCollectionRadiusAura(player.x, player.y, player.radius, player.collectionRadiusMultiplier, '#00FFFF'); // Desenha a aura de coleta (cor ciano)
            drawPlayer(); // Desenha jogador (agora com l√≥gica de sprite sheet e c√¢mera)
            drawProjectiles(); // Desenha proj√©teis (agora com l√≥gica de c√¢mera)
            drawEnemies(); // Desenha inimigos (agora com l√≥gica de c√¢mera)
            drawHealthBar(player.x, player.y, player.health, player.maxHealth); // Desenha barra de vida (agora com l√≥gica de c√¢mera)
            drawHeroicBar(); // Desenha a barra de habilidade heroica (NOVA POSI√á√ÉO)
            drawEffects(); // Desenha explos√µes e auras (agora com l√≥gica de c√¢mera)
        }

        // Fun√ß√£o de loop do jogo (recursiva via requestAnimationFrame)
        function gameLoop(currentTime) {
            if (gameRunning && !isLevelingUp && !isChoosingWeapon && !isChoosingInitialWeapon) {
                update(currentTime);
                draw();
            } else if (isLevelingUp || isChoosingWeapon || isChoosingInitialWeapon) {
                // Se um menu estiver aberto, apenas desenha (para exibir o menu sobre o jogo pausado)
                draw();
            }
            requestAnimationFrame(gameLoop); // Solicita o pr√≥ximo quadro de anima√ß√£o
        }

        // Configura√ß√£o inicial quando a janela √© carregada
        window.onload = function() {
            // Pr√©-carrega as sprite sheets dos personagens e sprites de proj√©teis usando o asset loader
            for (const charId in characters) {
                const charData = characters[charId];
                if (charData.spriteSheetUrl) assetLoader.addImage(`${charId}_sheet`, charData.spriteSheetUrl); // Carrega a sprite sheet principal
                if (charData.projectileSpriteUrl) assetLoader.addImage(`${charId}_projectile`, charData.projectileSpriteUrl); // Carrega a sprite do proj√©til
            }
            // Adiciona a imagem de fundo do mapa
            assetLoader.addImage('background_map', 'https://raw.githubusercontent.com/Gawlock/champions-of-nova-insula/refs/heads/main/assets/pxArt.png');

            // Uma vez que todos os assets s√£o carregados, exibe a mensagem de boas-vindas
            assetLoader.loadAll(() => {
                showMessageBox('Campe√µes de Nova Insula', 'Use W, A, S, D para se mover e sobreviva √†s hordas. Colete orbes de experi√™ncia para subir de n√≠vel e melhorar o seu her√≥i! Cuidado para n√£o ser tocado pelos inimigos! Pressione **X** para usar sua habilidade heroica quando a barra azul estiver cheia!', 'Continuar', showCharacterSelection);
            });
             gameLoop(); // Start the animation loop when all assets are loaded and the initial message is handled.
        };

        // Vari√°veis de entrada por toque
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoving = false;

        // Listeners de eventos de toque para movimento em dispositivos m√≥veis
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchMoving = true;
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touchMoving && gameRunning && !isLevelingUp && !isChoosingWeapon && !isChoosingInitialWeapon) {
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = currentX - touchStartX;
                const deltaY = currentY - touchStartY;
                // Calcula o √¢ngulo de movimento do toque para a seta
                if (deltaX !== 0 || deltaY !== 0) {
                    player.movementAngle = Math.atan2(deltaY, deltaX);
                }
                // Move o jogador com base no delta do toque (ajustado com um multiplicador para sensibilidade)
                const moveAmount = 0.15; // Ajuste para a sensibilidade do toque
                player.x += deltaX * moveAmount;
                player.y += deltaY * moveAmount;
                // Mant√©m o jogador dentro dos limites do MAPA
                player.x = Math.max(player.radius, Math.min(mapWidth - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(mapHeight - player.radius, player.y));
                touchStartX = currentX; // Atualiza o ponto inicial para o pr√≥ximo movimento
                touchStartY = currentY;
            }
        }, { passive: false });
        canvas.addEventListener('touchend', () => { touchMoving = false; });
    </script>
</body>
</html>
